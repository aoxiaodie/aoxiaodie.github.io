<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aoxiaodie</title>
  
  <subtitle>江南烟雨却痴缠</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aoxiaodie.github.io/"/>
  <updated>2019-11-20T14:44:17.587Z</updated>
  <id>https://aoxiaodie.github.io/</id>
  
  <author>
    <name>嗷小蝶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python入门之装饰器、迭代器、面向对象、异常处理等</title>
    <link href="https://aoxiaodie.github.io/2019/11/20/language/python-02/"/>
    <id>https://aoxiaodie.github.io/2019/11/20/language/python-02/</id>
    <published>2019-11-20T14:30:33.000Z</published>
    <updated>2019-11-20T14:44:17.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器：用于拓展原来函数功能的一种函数，目的是在不改变原函数名（或类名）的情况下，给函数增加新的功能。<br>特殊点：返回值也是一个函数。</p><p>例子：<br><code></code>python<br>import time<br>def time_it(func):<br>    def inner():<br>        start = time.time()<br>        func()<br>        end = time.time()<br>        print(‘用时:{}秒’.format(end-start))<br>    return inner</p><p>@time_it<br>def func1():<br>    time.sleep(2)<br>    print(“Func1 is running.”)</p><p>@time_it<br>def func2():<br>    print(“hello”)<br>    time.sleep(1)<br>    print(“world”)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    func1()<br>    func2()<br><code></code><br><br></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包：<br>1、在一个外函数中定义了一个内函数。<br>2、内函数里运用了外函数的临时变量。<br>3、并且外函数的返回值是内函数的引用。</p><p>例子：<br><code></code>python<br>def outer(a):<br>     b = 10<br>     def inner():<br>        print(a+b)<br>     return inner # 外函数的返回值是内函数的引用</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p><pre><code># 调用外函数传入参数5demo = outer(5)# demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数demo() # 15</code></pre><p><code></code><br><br><br><br><br><br></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p><code></code>python<br>  class className:</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>  def <strong>ini</strong>(self):</p><pre><code># 函数体，初始化</code></pre><h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><p>  def example(self):</p><pre><code># 函数体</code></pre><p><code></code><br>self代表类的实例，在定义类的方法时必须有，即使在调用时无需传参<br><br></p><h3 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h3><p><code></code>python<br>  class Test:<br>    def prt(self):<br>      print(self)<br>      print(self.<strong>class</strong>)</p><p>  t = Test()<br>  t.prt()<br><code></code></p><p>结果</p><blockquote><p>&lt;__main__.Test instance at 0x10d066878&gt;<br>__main__.Test</p></blockquote><p>可以参考Java的this关键字，self在这里有点像指针，指向类的本身。<br><br></p><h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><p>（1）__init__方法是初始化方法，负责对实例化对象进行属性值初始化;<br>（2）__new__是用来创建类并返回这个类的实例，比<strong>init</strong>方法先调用<br>（3）在对象生命周期调用结束时，__del__ 方法会被调用，可以将__del__理解为“析构函数”。</p><p>例子：<br><code></code>python<br>class Person:<br>    def <strong>new</strong>(cls, name, age):<br>        print(‘new’)<br>        if age &lt; 0: # 若age&lt;0则不创建对象<br>            raise ValueError(‘年龄不合法！’)<br>        obj = object.<strong>new</strong>(cls) # 否则创建对象<br>        return obj</p><pre><code>def __init__(self, name, age):    print(&apos;init&apos;)    self.name = name    self.age = agedef __del__(self):    print(&apos;结束了&apos;)</code></pre><p>person = Person(“小明”, 18)<br>print(person)<br><code></code><br><br></p><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><h3 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h3><p><code></code>python<br>class Employee:<br>    empCount = 0</p><pre><code>def __init__(self, name, salary):    self.name = name    self.salary = salary    Employee.empCount += 1def displayCount(self):    print &quot;Tolal Employee %d&quot; % Employee.empCountdef displayEmployee(self):    print &quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary</code></pre><p>emp1 = Employee(“Zara”, 2000)<br>emp2 = Employee(“vae”, 2000000)</p><p>emp1.displayEmployee()<br>emp2.displayEmployee()<br><code></code></p><p>输出结果：</p><blockquote><p>Name :  Zara ,Salary:  2000<br>Name :  vae ,Salary:  2000000<br>Total Employee 2</p></blockquote><p><br></p><h3 id="添加、修改、删除类的属性"><a href="#添加、修改、删除类的属性" class="headerlink" title="添加、修改、删除类的属性"></a>添加、修改、删除类的属性</h3><p><code>pythonemp1.age = 7  # 添加一个 &#39;age&#39; 属性emp1.age = 8  # 修改 &#39;age&#39; 属性del emp1.age  # 删除 &#39;age&#39; 属性</code><br><br></p><h3 id="访问属性的方法"><a href="#访问属性的方法" class="headerlink" title="访问属性的方法"></a>访问属性的方法</h3><p>（1）setattr()函数用于设置属性值，如果属性不存在则创建一个新的对象属性并赋值。<br><code>setattr(object,name,value)</code></p><blockquote><p>object-对象<br>name-对象属性<br>value-属性值</p></blockquote><p>（2）getattr()函数用于返回一个对象属性值。<br><code>getattr(object,name[,default])</code></p><blockquote><p>object-对象<br>name-对象属性<br>default-默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。</p></blockquote><p>例子：<br><code></code>python<br>class A(object):<br>    name = ‘vae’</p><p>a = A()<br>getattr(a,’name’) # 获取属性bar值<br>getattr(a,’age’) # 属性不存在，触发异常<br>getattr(a,’age’,17) # 属性不存在，但设置了默认值，返回17<br>setattr(a,’name’,’xusong’) # 设置属性bar值<br>setattr(a,’age’,18) # 创建新的对象属性并赋值<br><code></code></p><p>（3）hasattr(obj, name) : 检查是否存在一个属性。<br>（4）delattr(obj, name) : 删除属性。<br><br></p><h3 id="python内置的类属性"><a href="#python内置的类属性" class="headerlink" title="python内置的类属性"></a>python内置的类属性</h3><p>访问方法：类型.方法名<br>1、<strong>dict</strong> : 类的属性（包含一个字典，由类的数据属性组成）<br>2、<strong>doc</strong> :类的文档字符串<br>3、<strong>name</strong>: 类名<br>4、<strong>module</strong>: 类定义所在的模块（类的全名是’<strong>main</strong>.className’，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）<br>5、<strong>bases</strong> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）<br><br></p><h3 id="拦截属性"><a href="#拦截属性" class="headerlink" title="拦截属性"></a>拦截属性</h3><p>（1）__getattribute__(self, name):在属性被访问时自动调用。<br>（2）__getattr__(self, name):在属性被访问而对象没有这样的属性时调用。<br>（3）__setattr__(self, name, value):试图给属性赋值时调用。<br>（4）__delattr__(self, name):试图删除属性时调用。</p><p>例子：<br><code></code>python<br>class Person:<br>    def <strong>init</strong>(self):<br>        self.name = ‘vae’</p><pre><code>def __getattr__(self, item):    print(&apos;访问属性1：&apos;, item)    return None # 不存在则返回Nonedef __setattr__(self, key, value):    print(&apos;设置属性：&apos;, key, value)    super().__setattr__(key, value)def __delattr__(self, item):    print(&apos;删除属性：&apos;, item)    super().__delattr__(item)# def __getattribute__(self, item):#     print(&apos;访问属性0：&apos;, item)#     return super().__getattribute__(item)</code></pre><p>p = Person()<br>p.age = 18<br>print(p.name, getattr(p, ‘age’))<br>print(p.length)<br><code></code><br><br></p><h2 id="获取对象的属性"><a href="#获取对象的属性" class="headerlink" title="获取对象的属性"></a>获取对象的属性</h2><p>（1）type()可以获取对象的类型，也可以用来动态创建对象。<br>（2）isinstance()可以判断对象是否是类的实例。<br>（3）issubclass()可以判断类是否是其他类的子类。<br>（4）dir()、vars()、obj.__dict__ 获得一个对象的所有属性和方法。<br><br></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承父类的构造方法"><a href="#继承父类的构造方法" class="headerlink" title="继承父类的构造方法"></a>继承父类的构造方法</h3><p>1、子类需要自动调用父类的方法：子类不重写<strong>init</strong>()方法，实例化子类后，会自动调用父类的<strong>init</strong>()的方法。<br>2、子类不需要自动调用父类的方法：子类重写<strong>init</strong>()方法，实例化子类后，将不会自动调用父类的<strong>init</strong>()的方法。<br>3、子类重写<strong>init</strong>()方法又需要调用父类的方法：使用super关键词：<br><br></p><h3 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h3><p>在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数<br><br></p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）<br><br></p><h3 id="类的访问修饰符"><a href="#类的访问修饰符" class="headerlink" title="类的访问修饰符"></a>类的访问修饰符</h3><p>1、未加修饰则为公有public<code>foo</code><br>2、一个下划线为保护型protected<code>_foo</code><br>3、两个下划线为私有private<code>__foo</code></p><p>一个例子：<br><code></code>python<br>class Parent: # 定义父类<br>    parentAttr = 100<br>    def <strong>init</strong>(self):<br>        print “调用父类的构造方法”<br>    def parentMethod(self):<br>        print “调用父类的方法”<br>    def setAttr(self,attr):<br>        self.parentAttr = attr<br>    def getAttr(self):<br>        print “调用父类的属性” , self.parentAttr</p><p>class Child(Parent): # 定义子类<br>    def <strong>init</strong>(self):<br>        print “调用子类的构造方法”<br>    def childMethod(self):<br>        print “调用子类的方法”</p><p>c = Child()<br>c.childMethod()<br>c.parentMethod()<br>c.setAttr(200)<br>c.getAttr()<br><code>**python支持多重继承，</code>class C(A,B):<code></code>**<br><br></p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p><code></code>python<br>class Parent: # 定义父类<br>   def myMethod(self):<br>      print ‘调用父类方法’</p><p>class Child(Parent): # 定义子类<br>   def myMethod(self):<br>      print ‘调用子类方法’</p><p>c = Child() # 子类实例<br>c.myMethod()  # 子类调用重写方法<br><code></code><br><br></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>实现了方法__next__的对象称为迭代器:<br><code>pythonclass Iterator:    def __init__(self):        self.num = 0    def __next__(self):        self.num += 1        if self.num &gt; 100:            raise StopIteration        else:            return self.num</code></p><p>实现了方法__iter__的对象称为可迭代对象:<br><code>pythonclass Iterable:    def __init__(self):        self.num = 0    def __next__(self):        self.num += 1        if self.num &gt; 100:            raise StopIteration        else:            return self.num    def __iter__(self):    return self</code></p><p>__iter__方法需要返回一个迭代器。<br>调用迭代器的__next__方法会返回其下一个值，在没有值可返回时候应该抛出StopIteration异常。</p><p>使用内置函数next(iterator)与调用iterator.__next__方法等效。<br>使用iter()函数可以将可迭代对象转换成一个迭代器。<br><br></p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是一种使用普通函数语法定义的迭代器。<br>包含yield语句的函数都被称为生成器函数，其返回的结果称为生成器的迭代器，两者通称生成器。<br>使用生成器推导式也可以创建生成器。<br>生成器只能使用一次，再次使用需重新创建。<br><code></code>python<br>def gen():<br>    for i in range(100):<br>        yield i</p><p>gen1 = (i for i in range(100))<br>gen2 = gen()<br>print(gen1, gen2) # gen1和gen2都是生成器<br>print(list(gen1))<br>print(list(gen2))<br>print(list(gen1))<br>print(list(gen2))<br><code></code><br><br></p><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>定义：实现了__get__、__set__、 __delete__任意一个方法的类称为描述符, <strong>描述符是一种类</strong>。<br>实现了<strong>get</strong> 、__set__方法的称为数据描述符，其他的描述符称为非数据描述符。<br><a href="https://www.cnblogs.com/sfencs-hcy/p/10540469.html" target="_blank" rel="noopener">https://www.cnblogs.com/sfencs-hcy/p/10540469.html</a></p><p><code></code>python<br>class NotNegative(): # 描述符（一个类）<br>    def <strong>init</strong>(self,name):<br>        self.name = name<br>    def <strong>set</strong>(self, instance, value):<br>        if value &lt; 0:<br>            raise ValueError(self.name + ‘must be &gt;= 0’)<br>        else:<br>            instance.<strong>dict</strong>[self.name] = value</p><p>class Product(): # 使用描述符的类<br>    quantity = NotNegative(‘quantity’) # 引用描述符<br>    price = NotNegative(‘price’)</p><pre><code>def __init__(self,name,quantity,price):    self.name = name    self.quantity = quantity    self.price = price</code></pre><p>book = Product(‘mybook’,-1,5)<br><code></code><br><br></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>（1）__repr__:目的是为了表示清楚，是为开发者准备的。<br>（2）__str__:目的是可读性好，是为使用者准备的，未实现该方法时会调用<strong>repr</strong>方法。<br>（3）__slots__:定义该变量能限制类可以添加的属性，对子类不起作用。<br>（4）__call__:实现了该方法的对象称为可调用对象(callable)。<a href="https://www.cnblogs.com/z-joshua/p/7756891.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-joshua/p/7756891.html</a></p><p>如果类定义了<strong>call</strong>方法，则其实例可以作为函数调用：<br><code></code>python<br>class Entity:<br>    def <strong>init</strong>(self, size, x, y):<br>        self.x, self.y = x, y<br>        self.size = size</p><pre><code>def __call__(self, x, y):    self.x, self.y = x, y</code></pre><p>e = Entity(1, 2, 3)<br>e(4, 5)<br><code></code><br><br><br>（5）__dict__：提供给函数增加属性的功能。<br><br><br><br><br><br></p><h1 id="上下文协议"><a href="#上下文协议" class="headerlink" title="上下文协议"></a>上下文协议</h1><p>打开文件：<br><code>pythonwith open(&#39;file_name.txt&#39;) as f:    print(f.read())</code></p><h1 id="python文件和目录"><a href="#python文件和目录" class="headerlink" title="python文件和目录"></a>python文件和目录</h1><p>O/S文件/目录方法-具体参考文档</p><h2 id="读取键盘输入：raw-input和input，后者可以读取python表达式并输出结果"><a href="#读取键盘输入：raw-input和input，后者可以读取python表达式并输出结果" class="headerlink" title="读取键盘输入：raw_input和input，后者可以读取python表达式并输出结果"></a>读取键盘输入：raw_input和input，后者可以读取python表达式并输出结果</h2><p>str = raw_input(“请输入”)<br>print str</p><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>1、open函数<br>File object = open(file_name,[access_mode][,buffering])<br>file_name：文件名<br>access_mode：访问模式，默认为只读r<br>buffering：如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</p><p>file对象属性<br>file.closed，返回值true或者false<br>file.mode，访问模式<br>file.name，文件名<br>file.softspace，如果用print输出后，必须跟一个空格符，则返回false。否则返回true？</p><p>2、close方法<br>fileobject.close()</p><p>3、write方法<br>注：write()方法不会在字符串的结尾添加换行符(‘\n’)：<br>fileobject.write(string)，string即要写入打开的文件的内容</p><p>4、read方法<br>fileobject.read()</p><p>5、文件定位<br>tell()返回文件的当前位置<br>seek(offset[,from])改变当前文件的位置，offset表示要移动的字节数，from指定开始移动字节的参考位置</p><p>6、重命名和删除文件<br>rename(current_file_name, new_file_name)<br>remove(file_name)</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在当前目录下创建新的目录：mkdir()<br>改变当前目录（跳转？）：chdir()<br>显示当前目录：getcwd()<br>删除目录：rmdir()</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>捕捉异常：try/except<br>try/finally，finally一定执行</p><p>·</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h1&gt;&lt;p&gt;装饰器：用于拓展原来函数功能的一种函数，目的是在不改变原函数名（或类名）的情况下，给函数增加新的功能。&lt;br&gt;特殊点：返回值也是一个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python入门之基础语法、数据类型、函数等</title>
    <link href="https://aoxiaodie.github.io/2019/11/20/language/python-01/"/>
    <id>https://aoxiaodie.github.io/2019/11/20/language/python-01/</id>
    <published>2019-11-20T14:12:19.000Z</published>
    <updated>2019-11-20T14:33:59.510Z</updated>
    
    <content type="html"><![CDATA[<p>python中，变量是没有类型的，类型属于对象<br><br></p><h1 id="程序执行原理（类Java）"><a href="#程序执行原理（类Java）" class="headerlink" title="程序执行原理（类Java）"></a>程序执行原理（类Java）</h1><p>python-跨平台<br>源程序.py——编译——&gt;字节码.pyc</p><blockquote><p>编译语句：python -m file_name</p></blockquote><p>字节码在PVM（python虚拟机）中运行<br><br><br><br><br><br></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h2><p>Python以缩进来控制代码块（类、函数以及其他逻辑判断等）——Python对格式的要求非常严格<br>多行语句用“\”分隔显示<br><code>pythontotal  = item_one + \     item_two</code><br>语句中包含[]，{}，()则无需多行连接符<br><br></p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>单引号（’），双引号（”），三引号（’’’）或（”””）三引号可以用于多行注释<br><br></p><p>##注释<br>‘#’<br><br></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><code>raw_input(&quot;请输入：&quot;)</code><br><br></p><h2 id="一行多条语句用（-）隔开"><a href="#一行多条语句用（-）隔开" class="headerlink" title="一行多条语句用（;）隔开"></a>一行多条语句用（;）隔开</h2><p><br></p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>print默认换行输出，加（,）取消换行<br><br><br><br><br><br></p><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="数字number"><a href="#数字number" class="headerlink" title="数字number"></a>数字number</h2><h3 id="数据类型不允许改变"><a href="#数据类型不允许改变" class="headerlink" title="数据类型不允许改变"></a>数据类型不允许改变</h3><blockquote><p>int     long（python2）     float    complex</p></blockquote><p><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>（1）<br>从左往右索引默认从0开始<br>从右往左索引默认从-1开始</p><p>获取部分字符串[头下标:尾下标]，算头不算尾<br>如：<br><code>s = &#39;abcdefg&#39;</code></p><blockquote><p>S[1:5]结果是’bcde’</p></blockquote><p>（2）字符串格式化<br>实例：<br><code>print &quot;My name is %s and weight is %d kg!&quot; % (&#39;Zara&#39;, 21)</code></p><blockquote><p>输出结果：My name is Zara and weight is 21 kg!</p></blockquote><p>（3）Unicode 字符串<br>定义：<code>u&#39;hello world&#39;</code><br><br></p><h3 id="解码和编码"><a href="#解码和编码" class="headerlink" title="解码和编码"></a>解码和编码</h3><p>字符str在内存中都是以unicode编码存储</p><p>（1）编码：encode的作用是将unicode编码转换成其他编码的字符串<br>encode()函数的主要作用就是告诉系统，我需要将unicode按照什么格式编码成bytes对象。编码后的bytes一般输出格式前边带一个b，表示为bytes对象<br><code>u = s.encode(&#39;utf-8&#39;)</code><br><code>u = s.encode(&#39;gbk&#39;)</code><br>（2）解码：decode的作用是将其他编码的字符串解码成unicode编码<br>decode()函数的作用就是告诉系统，我们需要将当前bytes对象按照什么编码格式进行解码<br><code>s = u.decode(&#39;gbk&#39;)</code><br><br></p><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>用 <strong>[]</strong> 标识，允许更新<br>+是列表连接运算符，*是重复操作</p><h3 id="列表元素的操作"><a href="#列表元素的操作" class="headerlink" title="列表元素的操作"></a>列表元素的操作</h3><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>[2:]从第三个开始到结束<br>[:3]从开始到第三个<br>[:]全部</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p><code>pythonlist1 = []list1.append(&#39;hello&#39;)list1.append(&#39;world&#39;)print list1</code><br><br></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>pythonlist2 = [&#39;hello&#39;,&#39;world&#39;,2019,1107]del list2[2]print list2</code><br><br></p><h4 id="插入-移除"><a href="#插入-移除" class="headerlink" title="插入/移除"></a>插入/移除</h4><p><code>pythonlist2.insert(2,&#39;test&#39;) # 在指定位置插入print(list2)list2.remove(&#39;test&#39;) # 移除指定元素print(list2)print(list2.pop(2)) # 出列表print(list2)</code></p><blockquote><p>结果：<br>[‘hello’,’world’,’test’,2019,1107]<br>[‘hello’,’world’,2019,1107]<br>2019<br>[‘hello’,’world’,1107]</p></blockquote><p><br></p><h4 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h4><p><code>pythonlist3 = [&#39;hello&#39;,&#39;hello&#39;,2019]print(len(list3)) # 列表元素的个数print(list3.count(&#39;hello&#39;)) # 元素&#39;hello&#39;的个数</code><br><br></p><h4 id="元素的访问"><a href="#元素的访问" class="headerlink" title="元素的访问"></a>元素的访问</h4><p><code>pythonprint(list3.index(&#39;hello&#39;))print(list3.index(&#39;hello&#39;,2))</code></p><blockquote><p>结果：<br>0<br>1</p></blockquote><p><br></p><h3 id="列表的操作"><a href="#列表的操作" class="headerlink" title="列表的操作"></a>列表的操作</h3><h4 id="列表的翻转"><a href="#列表的翻转" class="headerlink" title="列表的翻转"></a>列表的翻转</h4><p><code>list3.reverse()</code><br><br></p><h4 id="浅拷贝copy"><a href="#浅拷贝copy" class="headerlink" title="浅拷贝copy"></a>浅拷贝copy</h4><p><code>list4 = list3.copy()</code><br><br></p><h4 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h4><p><code></code>python<br>print(“====== 遍历列表方法1 ======”)<br>for i in list1:<br>    print(“序号：%s   值：%s” % (list1.index(i), i))</p><p>print(“====== 遍历列表方法2 iter ======”)<br>for i in iter(list1):<br>    print(“序号：%s   值：%s” % (list1.index(i), i))</p><p>print(“====== 遍历列表方法3 ======”)<br>for i, val in enumerate(list1):<br>    print(“序号：%s   值：%s” % (i, val))</p><p>print(“====== 遍历列表方法3.1 ======”)<br>for i, val in enumerate(list1, 2):<br>    print(“序号：%s   值：%s” % (i, val))</p><p>print(“====== 遍历列表方法4 ======”)<br>for i in range(len(list1)):<br>    print(“序号：%s   值：%s” % (i, list1[i]))<br><code></code></p><blockquote><p>备注：<br>1、iter()，python内置函数，用于生成迭代器<br>2、enumerate()，python内置函数，用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中</p></blockquote><p><br></p><h2 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h2><p>用 <strong>()</strong> 标识，以逗号隔开，不能二次赋值，即 <strong>不允许更新</strong><br>元组的元素值不允许修改删除，只能将整个元组删除<code>del tup</code><br>元组可以用“+”进行拼接<br><br></p><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>列表是有序的对象集合，字典是无序的对象集合<br>Key-value存储<br>用 <strong>{}</strong> 标识</p><h3 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h3><h4 id="添加、修改"><a href="#添加、修改" class="headerlink" title="添加、修改"></a>添加、修改</h4><p><code>pythondict1 = {&#39;name&#39;:&#39;vae&#39;, &#39;age&#39;:30}dict1[&#39;age&#39;] = 32 # 更新dict1[&#39;home&#39;] = &#39;Anhui&#39; # 添加print(dict1[&#39;name&#39;]) # 输出</code></p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p><code>pythondel dict1[&#39;name&#39;] # 删除键&#39;name&#39;的条目dict1.clear() # 清空字典所有条目del dict1 # 删除字典</code><br><br></p><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p><code>pythonprint(dict1[&#39;name&#39;])print(dict1.get(&#39;birthday&#39;)) # 返回None，区别于上一种方法，不会报错</code><br><br></p><h3 id="其他的一些方法"><a href="#其他的一些方法" class="headerlink" title="其他的一些方法"></a>其他的一些方法</h3><h4 id="items"><a href="#items" class="headerlink" title="items()"></a>items()</h4><p>item()方法把字典中每对key和value组成一个元组，并把这些元组放在列表中返回<br><code>print(dict1.items())</code><br>结果为：dict1.items([(‘name’,’vae’),(‘age’,’30’)])</p><p>遍历字典：<br><code>pythonfor key,value in dict1.items()    print(key,value)</code></p><h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><p>以列表的形式返回该字典中的key值<br><code>print(dict1.keys())</code><br>结果为：dict1.items([‘name’,’vae’])<br><br></p><h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><p>以列表的形式返回该字典中的values值<br><br></p><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>无序，不可重复<br>用 <strong>{}</strong> 标识<br>除整型、字符型等，集合中还可存储元组、列表、字典<br><br></p><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><p>例子：<br><code>pythonmcase = {&#39;a&#39;:10,&#39;b&#39;:34}mcase_new = {v:k for k,v in mcase.items()}print(mcase_new)</code></p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="转整型"><a href="#转整型" class="headerlink" title="转整型"></a>转整型</h3><p>内置函数int()：<code>int(x,base)</code></p><blockquote><p>x为字符串或数字，base为进制数，默认十进制，结果为base进制中的x换算成十进制的值</p></blockquote><p><br></p><h3 id="转复合型"><a href="#转复合型" class="headerlink" title="转复合型"></a>转复合型</h3><p><code>complex(a,b)</code>结果为a+bj<br><br><br><br><br><br></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>| 运算符 | 描述 | 举例 |<br>| / | 除，结果为浮点数 | 5/2结果为2.5 |<br>| // | 除，结果为整数 | 5/2结果为2 |<br>| <strong> | 乘方 | 2</strong>5结果为32 |<br><br></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><br></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp;    按位与<br>|    按位或<br>^    按位异或，当两对应的二进位相异时，结果为1<br>~    按位取反<br>&lt;&lt;    左移运算符<br>>&gt;    右移运算符<br><br></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>and     x and y    如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值<br>or    x or y     如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值<br>not    not x     如果 x 为 True，返回 False 。如果 x 为 False，它返回 True<br><br></p><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><p>in<br>not in<br><br></p><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p>is    x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False<br>is not    x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。<br><br></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><br><br><br><br><br></p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>（1）while<br>（2）for<br><code>pythonfor letter in &#39;string&#39;:print letter #操作语句</code></p><p>（3）break、continue、pass</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>格式：<br><code>pythondef 函数名(变量名):    &quot;文档说明&quot;    函数体    return</code><br>设置默认值后，有传参则用传入的参数，没有则用默认值<br><br></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>最简单的传参方式，在调用函数时必须传递，传参的时候需要注意顺序。<br><br></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>使用名称指定的参数成为关键字参数，关键字参数必须在位置参数之后，传参时对于参数的顺序没有要求。<br>可变参数允许传入0个～多个参数，而关键字参数允许在调用时以字典形式传入0个或多个参数（注意区别，一个是字典一个是列表）；在传递参数时用等号（=）连接键和值。<br><br></p><h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>命名关键字参数在关键字参数的基础上限制传入的的关键字的变量名；<br>和普通关键字参数不同，命名关键字参数需要一个用来区分的分隔符<em>，它后面的参数被认为是命名关键字参数。<br><code></code>python<br>def foo1(name, </em>, age, sex): # <em>分隔符后面的age和sex为命名关键字参数<br>    print(name,age,sex)<br><code>或者</code>python<br>def foo2(name, </em>args, age, sex): # 可变参数后面的age和sex为命名关键字参数<br>    print(name,args,age,sex)<br><code></code><br><br></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时使用一些包含默认值的参数。<br><strong>默认参数必须指向不可变对象</strong><br><br></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>传入参数的个数是可变的。<br><code></code>python<br>def foo3(<em>args): # 在参数名前加</em><br>    print(args)</p><p>foo1(‘vae’,’许嵩’,30)<br><code></code></p><blockquote><p>结果：<br>(‘vae’,’许嵩’,30)</p></blockquote><p><br></p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>浅拷贝<code>b = copy.copy(a)</code>，复制的是对象的引用，所以当原始列表改变时，复制的列表也会随之改变；<br>深拷贝<code>b = copy.deepcopy(a)</code>，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变。<br>直接赋值与浅拷贝相同。<br><br></p><h2 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h2><p><br></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在一个python程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。<br>四种作用域：</p><blockquote><p>L（Local）：最内层，包含局部变量，比如一个函数/方法内部。<br>E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。<br>G（Global）：当前脚本的最外层，比如当前模块的全局变量。<br>B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。</p></blockquote><p>例子：<br><code>pythontotal = 1 # 全局变量def sum(arg1,arg2):    total = arg1 + arg2 # 这里的total是重新定义的，是局部变量    return total</code><br>global关键字：<br><code>pythontotal = 1 # 全局变量def sum(arg1,arg2):    global total    total = arg1 + arg2 # 这里的total是全局变量    return total</code><br>nonlocal关键字<br><code>pythondef foo4():    num = 1    def foo5():        nonlocal num # nonlocal关键字声明        num = 100        print(num)    foo5()    print(num)</code><br><br></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>语法<code>lambda 参数列表 : 表达式</code></p><blockquote><p>1、匿名函数冒号后面的表达式有且只能有一个；<br>2、匿名函数自带return，而return的结果就是表达式的计算后的结果。</p></blockquote><p>例子：<br><code>pythonsum = lambda num1,num2:num1+num2sum(1,2)</code><br><br><br><br><br><br></p><h1 id="组包和解包"><a href="#组包和解包" class="headerlink" title="组包和解包"></a>组包和解包</h1><h2 id="组包"><a href="#组包" class="headerlink" title="组包"></a>组包</h2><p><code>pythona = 1,2,3print(a)</code><br>解释器自动将1，2，3组包成一个元组，然后赋值给a<br><br></p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p><code>pythonm,n,k = (1,2,3)print(m)print(n)print(k)</code><br>解析式自动将元组(1,2,3)解包并分别赋值给m，n，k</p><p>func( *args,*<em> kwargs) 与 func(args,kwargs）返回的数据不同：<br>    \</em>或者*<em>具有解包的作用，\</em>用来将普通参数元组解开 **用来将关键字参数字典解开。<br>    **kwargs只能在调用函数时使用。</p><p>例子：<br><code></code>python<br>def func1(*args, **kwargs):<br>    print(args)<br>    print(kwargs)</p><p>func1(10, 20, n=30, m=40)<br><code></code><br><br><br><br><br><br></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块即一个python文件，以.py结尾</p><p>（1）模块引入<br>import 模块名<br>模块名.函数名</p><p>from 模块名 import 函数名<br>from 模块名 import  *  # 全部导入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中，变量是没有类型的，类型属于对象&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;程序执行原理（类Java）&quot;&gt;&lt;a href=&quot;#程序执行原理（类Java）&quot; class=&quot;headerlink&quot; title=&quot;程序执行原理（类Java）&quot;&gt;&lt;/a&gt;程序执行原理（类
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>python入门之基础语法、数据类型、函数等</title>
    <link href="https://aoxiaodie.github.io/2019/11/20/games-development/python/python-01/"/>
    <id>https://aoxiaodie.github.io/2019/11/20/games-development/python/python-01/</id>
    <published>2019-11-20T14:12:19.000Z</published>
    <updated>2019-11-20T14:31:02.022Z</updated>
    
    <content type="html"><![CDATA[<p>python中，变量是没有类型的，类型属于对象<br><br></p><h1 id="程序执行原理（类Java）"><a href="#程序执行原理（类Java）" class="headerlink" title="程序执行原理（类Java）"></a>程序执行原理（类Java）</h1><p>python-跨平台<br>源程序.py——编译——&gt;字节码.pyc</p><blockquote><p>编译语句：python -m file_name</p></blockquote><p>字节码在PVM（python虚拟机）中运行<br><br><br><br><br><br></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h2><p>Python以缩进来控制代码块（类、函数以及其他逻辑判断等）——Python对格式的要求非常严格<br>多行语句用“\”分隔显示<br><code>pythontotal  = item_one + \     item_two</code><br>语句中包含[]，{}，()则无需多行连接符<br><br></p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>单引号（’），双引号（”），三引号（’’’）或（”””）三引号可以用于多行注释<br><br></p><p>##注释<br>‘#’<br><br></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><code>raw_input(&quot;请输入：&quot;)</code><br><br></p><h2 id="一行多条语句用（-）隔开"><a href="#一行多条语句用（-）隔开" class="headerlink" title="一行多条语句用（;）隔开"></a>一行多条语句用（;）隔开</h2><p><br></p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>print默认换行输出，加（,）取消换行<br><br><br><br><br><br></p><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><h2 id="数字number"><a href="#数字number" class="headerlink" title="数字number"></a>数字number</h2><h3 id="数据类型不允许改变"><a href="#数据类型不允许改变" class="headerlink" title="数据类型不允许改变"></a>数据类型不允许改变</h3><blockquote><p>int     long（python2）     float    complex</p></blockquote><p><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>（1）<br>从左往右索引默认从0开始<br>从右往左索引默认从-1开始</p><p>获取部分字符串[头下标:尾下标]，算头不算尾<br>如：<br><code>s = &#39;abcdefg&#39;</code></p><blockquote><p>S[1:5]结果是’bcde’</p></blockquote><p>（2）字符串格式化<br>实例：<br><code>print &quot;My name is %s and weight is %d kg!&quot; % (&#39;Zara&#39;, 21)</code></p><blockquote><p>输出结果：My name is Zara and weight is 21 kg!</p></blockquote><p>（3）Unicode 字符串<br>定义：<code>u&#39;hello world&#39;</code><br><br></p><h3 id="解码和编码"><a href="#解码和编码" class="headerlink" title="解码和编码"></a>解码和编码</h3><p>字符str在内存中都是以unicode编码存储</p><p>（1）编码：encode的作用是将unicode编码转换成其他编码的字符串<br>encode()函数的主要作用就是告诉系统，我需要将unicode按照什么格式编码成bytes对象。编码后的bytes一般输出格式前边带一个b，表示为bytes对象<br><code>u = s.encode(&#39;utf-8&#39;)</code><br><code>u = s.encode(&#39;gbk&#39;)</code><br>（2）解码：decode的作用是将其他编码的字符串解码成unicode编码<br>decode()函数的作用就是告诉系统，我们需要将当前bytes对象按照什么编码格式进行解码<br><code>s = u.decode(&#39;gbk&#39;)</code><br><br></p><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>用 <strong>[]</strong> 标识，允许更新<br>+是列表连接运算符，*是重复操作</p><h3 id="列表元素的操作"><a href="#列表元素的操作" class="headerlink" title="列表元素的操作"></a>列表元素的操作</h3><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>[2:]从第三个开始到结束<br>[:3]从开始到第三个<br>[:]全部</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p><code>pythonlist1 = []list1.append(&#39;hello&#39;)list1.append(&#39;world&#39;)print list1</code><br><br></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>pythonlist2 = [&#39;hello&#39;,&#39;world&#39;,2019,1107]del list2[2]print list2</code><br><br></p><h4 id="插入-移除"><a href="#插入-移除" class="headerlink" title="插入/移除"></a>插入/移除</h4><p><code>pythonlist2.insert(2,&#39;test&#39;) # 在指定位置插入print(list2)list2.remove(&#39;test&#39;) # 移除指定元素print(list2)print(list2.pop(2)) # 出列表print(list2)</code></p><blockquote><p>结果：<br>[‘hello’,’world’,’test’,2019,1107]<br>[‘hello’,’world’,2019,1107]<br>2019<br>[‘hello’,’world’,1107]</p></blockquote><p><br></p><h4 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h4><p><code>pythonlist3 = [&#39;hello&#39;,&#39;hello&#39;,2019]print(len(list3)) # 列表元素的个数print(list3.count(&#39;hello&#39;)) # 元素&#39;hello&#39;的个数</code><br><br></p><h4 id="元素的访问"><a href="#元素的访问" class="headerlink" title="元素的访问"></a>元素的访问</h4><p><code>pythonprint(list3.index(&#39;hello&#39;))print(list3.index(&#39;hello&#39;,2))</code></p><blockquote><p>结果：<br>0<br>1</p></blockquote><p><br></p><h3 id="列表的操作"><a href="#列表的操作" class="headerlink" title="列表的操作"></a>列表的操作</h3><h4 id="列表的翻转"><a href="#列表的翻转" class="headerlink" title="列表的翻转"></a>列表的翻转</h4><p><code>list3.reverse()</code><br><br></p><h4 id="浅拷贝copy"><a href="#浅拷贝copy" class="headerlink" title="浅拷贝copy"></a>浅拷贝copy</h4><p><code>list4 = list3.copy()</code><br><br></p><h4 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h4><p><code></code>python<br>print(“====== 遍历列表方法1 ======”)<br>for i in list1:<br>    print(“序号：%s   值：%s” % (list1.index(i), i))</p><p>print(“====== 遍历列表方法2 iter ======”)<br>for i in iter(list1):<br>    print(“序号：%s   值：%s” % (list1.index(i), i))</p><p>print(“====== 遍历列表方法3 ======”)<br>for i, val in enumerate(list1):<br>    print(“序号：%s   值：%s” % (i, val))</p><p>print(“====== 遍历列表方法3.1 ======”)<br>for i, val in enumerate(list1, 2):<br>    print(“序号：%s   值：%s” % (i, val))</p><p>print(“====== 遍历列表方法4 ======”)<br>for i in range(len(list1)):<br>    print(“序号：%s   值：%s” % (i, list1[i]))<br><code></code></p><blockquote><p>备注：<br>1、iter()，python内置函数，用于生成迭代器<br>2、enumerate()，python内置函数，用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中</p></blockquote><p><br></p><h2 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h2><p>用 <strong>()</strong> 标识，以逗号隔开，不能二次赋值，即 <strong>不允许更新</strong><br>元组的元素值不允许修改删除，只能将整个元组删除<code>del tup</code><br>元组可以用“+”进行拼接<br><br></p><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>列表是有序的对象集合，字典是无序的对象集合<br>Key-value存储<br>用 <strong>{}</strong> 标识</p><h3 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h3><h4 id="添加、修改"><a href="#添加、修改" class="headerlink" title="添加、修改"></a>添加、修改</h4><p><code>pythondict1 = {&#39;name&#39;:&#39;vae&#39;, &#39;age&#39;:30}dict1[&#39;age&#39;] = 32 # 更新dict1[&#39;home&#39;] = &#39;Anhui&#39; # 添加print(dict1[&#39;name&#39;]) # 输出</code></p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p><code>pythondel dict1[&#39;name&#39;] # 删除键&#39;name&#39;的条目dict1.clear() # 清空字典所有条目del dict1 # 删除字典</code><br><br></p><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p><code>pythonprint(dict1[&#39;name&#39;])print(dict1.get(&#39;birthday&#39;)) # 返回None，区别于上一种方法，不会报错</code><br><br></p><h3 id="其他的一些方法"><a href="#其他的一些方法" class="headerlink" title="其他的一些方法"></a>其他的一些方法</h3><h4 id="items"><a href="#items" class="headerlink" title="items()"></a>items()</h4><p>item()方法把字典中每对key和value组成一个元组，并把这些元组放在列表中返回<br><code>print(dict1.items())</code><br>结果为：dict1.items([(‘name’,’vae’),(‘age’,’30’)])</p><p>遍历字典：<br><code>pythonfor key,value in dict1.items()    print(key,value)</code></p><h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><p>以列表的形式返回该字典中的key值<br><code>print(dict1.keys())</code><br>结果为：dict1.items([‘name’,’vae’])<br><br></p><h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><p>以列表的形式返回该字典中的values值<br><br></p><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>无序，不可重复<br>用 <strong>{}</strong> 标识<br>除整型、字符型等，集合中还可存储元组、列表、字典<br><br></p><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><p>例子：<br><code>pythonmcase = {&#39;a&#39;:10,&#39;b&#39;:34}mcase_new = {v:k for k,v in mcase.items()}print(mcase_new)</code></p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="转整型"><a href="#转整型" class="headerlink" title="转整型"></a>转整型</h3><p>内置函数int()：<code>int(x,base)</code></p><blockquote><p>x为字符串或数字，base为进制数，默认十进制，结果为base进制中的x换算成十进制的值</p></blockquote><p><br></p><h3 id="转复合型"><a href="#转复合型" class="headerlink" title="转复合型"></a>转复合型</h3><p><code>complex(a,b)</code>结果为a+bj<br><br><br><br><br><br></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>| 运算符 | 描述 | 举例 |<br>| / | 除，结果为浮点数 | 5/2结果为2.5 |<br>| // | 除，结果为整数 | 5/2结果为2 |<br>| <strong> | 乘方 | 2</strong>5结果为32 |<br><br></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><br></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp;    按位与<br>|    按位或<br>^    按位异或，当两对应的二进位相异时，结果为1<br>~    按位取反<br>&lt;&lt;    左移运算符<br>>&gt;    右移运算符<br><br></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>and     x and y    如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值<br>or    x or y     如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值<br>not    not x     如果 x 为 True，返回 False 。如果 x 为 False，它返回 True<br><br></p><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><p>in<br>not in<br><br></p><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p>is    x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False<br>is not    x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。<br><br></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><br><br><br><br><br></p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>（1）while<br>（2）for<br><code>pythonfor letter in &#39;string&#39;:print letter #操作语句</code></p><p>（3）break、continue、pass</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>格式：<br><code>pythondef 函数名(变量名):    &quot;文档说明&quot;    函数体    return</code><br>设置默认值后，有传参则用传入的参数，没有则用默认值<br><br></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>最简单的传参方式，在调用函数时必须传递，传参的时候需要注意顺序。<br><br></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>使用名称指定的参数成为关键字参数，关键字参数必须在位置参数之后，传参时对于参数的顺序没有要求。<br>可变参数允许传入0个～多个参数，而关键字参数允许在调用时以字典形式传入0个或多个参数（注意区别，一个是字典一个是列表）；在传递参数时用等号（=）连接键和值。<br><br></p><h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>命名关键字参数在关键字参数的基础上限制传入的的关键字的变量名；<br>和普通关键字参数不同，命名关键字参数需要一个用来区分的分隔符<em>，它后面的参数被认为是命名关键字参数。<br><code></code>python<br>def foo1(name, </em>, age, sex): # <em>分隔符后面的age和sex为命名关键字参数<br>    print(name,age,sex)<br><code>或者</code>python<br>def foo2(name, </em>args, age, sex): # 可变参数后面的age和sex为命名关键字参数<br>    print(name,args,age,sex)<br><code></code><br><br></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时使用一些包含默认值的参数。<br><strong>默认参数必须指向不可变对象</strong><br><br></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>传入参数的个数是可变的。<br><code></code>python<br>def foo3(<em>args): # 在参数名前加</em><br>    print(args)</p><p>foo1(‘vae’,’许嵩’,30)<br><code></code></p><blockquote><p>结果：<br>(‘vae’,’许嵩’,30)</p></blockquote><p><br></p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>浅拷贝<code>b = copy.copy(a)</code>，复制的是对象的引用，所以当原始列表改变时，复制的列表也会随之改变；<br>深拷贝<code>b = copy.deepcopy(a)</code>，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变。<br>直接赋值与浅拷贝相同。<br><br></p><h2 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h2><p><br></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在一个python程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。<br>四种作用域：</p><blockquote><p>L（Local）：最内层，包含局部变量，比如一个函数/方法内部。<br>E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。<br>G（Global）：当前脚本的最外层，比如当前模块的全局变量。<br>B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。</p></blockquote><p>例子：<br><code>pythontotal = 1 # 全局变量def sum(arg1,arg2):    total = arg1 + arg2 # 这里的total是重新定义的，是局部变量    return total</code><br>global关键字：<br><code>pythontotal = 1 # 全局变量def sum(arg1,arg2):    global total    total = arg1 + arg2 # 这里的total是全局变量    return total</code><br>nonlocal关键字<br><code>pythondef foo4():    num = 1    def foo5():        nonlocal num # nonlocal关键字声明        num = 100        print(num)    foo5()    print(num)</code><br><br></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>语法<code>lambda 参数列表 : 表达式</code></p><blockquote><p>1、匿名函数冒号后面的表达式有且只能有一个；<br>2、匿名函数自带return，而return的结果就是表达式的计算后的结果。</p></blockquote><p>例子：<br><code>pythonsum = lambda num1,num2:num1+num2sum(1,2)</code><br><br><br><br><br><br></p><h1 id="组包和解包"><a href="#组包和解包" class="headerlink" title="组包和解包"></a>组包和解包</h1><h2 id="组包"><a href="#组包" class="headerlink" title="组包"></a>组包</h2><p><code>pythona = 1,2,3print(a)</code><br>解释器自动将1，2，3组包成一个元组，然后赋值给a<br><br></p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p><code>pythonm,n,k = (1,2,3)print(m)print(n)print(k)</code><br>解析式自动将元组(1,2,3)解包并分别赋值给m，n，k</p><p>func( *args,*<em> kwargs) 与 func(args,kwargs）返回的数据不同：<br>    \</em>或者*<em>具有解包的作用，\</em>用来将普通参数元组解开 **用来将关键字参数字典解开。<br>    **kwargs只能在调用函数时使用。</p><p>例子：<br><code></code>python<br>def func1(*args, **kwargs):<br>    print(args)<br>    print(kwargs)</p><p>func1(10, 20, n=30, m=40)<br><code></code><br><br><br><br><br><br></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块即一个python文件，以.py结尾</p><p>（1）模块引入<br>import 模块名<br>模块名.函数名</p><p>from 模块名 import 函数名<br>from 模块名 import  *  # 全部导入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中，变量是没有类型的，类型属于对象&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;程序执行原理（类Java）&quot;&gt;&lt;a href=&quot;#程序执行原理（类Java）&quot; class=&quot;headerlink&quot; title=&quot;程序执行原理（类Java）&quot;&gt;&lt;/a&gt;程序执行原理（类
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>非标业务</title>
    <link href="https://aoxiaodie.github.io/2019/04/02/feibiao/"/>
    <id>https://aoxiaodie.github.io/2019/04/02/feibiao/</id>
    <published>2019-04-02T02:56:40.000Z</published>
    <updated>2019-05-07T07:37:52.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“非标”产品"><a href="#“非标”产品" class="headerlink" title="“非标”产品"></a>“非标”产品</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>未在银行间市场及证券交易所市场交易的债券性资产，<br>包括但不限于信贷资产、信托贷款、委托债权、承兑汇票、信用证、应收账款、各类受（收）益权、<br>带回购条款的股权性融资等。<br><br></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>①没有活跃、集中的交易场所，未在银行间市场及证券交易所市场交易和债权性资产。<br>②“非标”资产公允价难以可靠取得。<br><br></p><h2 id="非标产生的背景（或者说优点）"><a href="#非标产生的背景（或者说优点）" class="headerlink" title="非标产生的背景（或者说优点）"></a>非标产生的背景（或者说优点）</h2><p>1、可以避免常规贷款的政策限制；<br>2、加快流程，提高效率；<br>3、结构灵活；<br>4、夸大营收；</p><h2 id="5、利收转中收。"><a href="#5、利收转中收。" class="headerlink" title="5、利收转中收。"></a>5、利收转中收。</h2><p><br><br><br><br><br></p><h1 id="信托"><a href="#信托" class="headerlink" title="信托"></a>信托</h1><h2 id="信托公司"><a href="#信托公司" class="headerlink" title="信托公司"></a>信托公司</h2><p>信托公司是银监会监管的非银行金融机构<br><br></p><h2 id="信贷业务"><a href="#信贷业务" class="headerlink" title="信贷业务"></a>信贷业务</h2><p>委托人做投资，将资金交给受托人（信托公司）；<br>受托人通过信贷业务（如贷款，购买信贷资产、票据等）放款，将得到的收益交付给委托人（收益可能是差价、利息等）；<br>第三方（反正就是拿现金的）<br>此过程中：<br>委托人获取利息；<br>受托人收取一定的费用；<br>第三方（收款方）获得流动资金。<br><br></p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>1、贷款：（个人资金通过信托公司放款给公司，到期收还本金和利息，信托公司收取服务费，公司通过贷款获取流动资金）<br>2、信贷资产转让<br>3、票据转让<br>4、股权投资<br>5、股权收益权<br>6、其他收益权<br>7、财产权（非现金财产）<br>8、理财产品投资、信托产品投资、其他投资</p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“非标”产品&quot;&gt;&lt;a href=&quot;#“非标”产品&quot; class=&quot;headerlink&quot; title=&quot;“非标”产品&quot;&gt;&lt;/a&gt;“非标”产品&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我乐意+惟爱你+在那不遥远的地方（合唱特别版）</title>
    <link href="https://aoxiaodie.github.io/2019/02/27/vae-fans/vae-fans-new/"/>
    <id>https://aoxiaodie.github.io/2019/02/27/vae-fans/vae-fans-new/</id>
    <published>2019-02-27T04:25:35.000Z</published>
    <updated>2019-02-27T05:31:57.924Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个一百三十九个人的故事，四年前，我创建了一个群，我们因为喜欢许嵩而聚在一起。四年后，大家相继准备离开，我们策划完成这个视频。<br>执手走过尽四个年头，听歌聊天，聚餐看演唱会，我们都一起做过，然此去经年，重聚未可期。<br>漫漫一生，相逢别离，未能尽言。<br>愿数年后，大家仍记得，<br>曾经有一群可爱的人，<br>以及那些一起走过的最美好的青春岁月。<br>B站链接：<a href="http://www.bilibili.com/video/av42665243?share_medium=android&amp;share_source=copy_link&amp;bbid=69B0E2C8-17B3-445F-86CC-A0D234472E8B30552infoc&amp;ts=1550245939958" target="_blank" rel="noopener">我乐意+惟爱你+在那不遥远的地方（春节特别版）</a><br>微博链接：<a href="https://m.weibo.cn/1852414964/4336123788903941" target="_blank" rel="noopener">我乐意+惟爱你+在那不遥远的地方（春节特别版）</a></p><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"/assets/audio/VaeFans02.webm"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个一百三十九个人的故事，四年前，我创建了一个群，我们因为喜欢许嵩而聚在一起。四年后，大家相继准备离开，我们策划完成这个视频。&lt;br&gt;执手走过尽四个年头，听歌聊天，聚餐看演唱会，我们都一起做过，然此去经年，重聚未可期。&lt;br&gt;漫漫一生，相逢别离，未能尽言。&lt;br&gt;愿数年
      
    
    </summary>
    
      <category term="南昌大学许嵩歌迷群纪念作品" scheme="https://aoxiaodie.github.io/categories/%E5%8D%97%E6%98%8C%E5%A4%A7%E5%AD%A6%E8%AE%B8%E5%B5%A9%E6%AD%8C%E8%BF%B7%E7%BE%A4%E7%BA%AA%E5%BF%B5%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="收藏" scheme="https://aoxiaodie.github.io/tags/%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件自动化测试</title>
    <link href="https://aoxiaodie.github.io/2018/11/05/Testing/automated-testing/"/>
    <id>https://aoxiaodie.github.io/2018/11/05/Testing/automated-testing/</id>
    <published>2018-11-05T03:31:22.000Z</published>
    <updated>2019-02-26T06:01:38.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h2><p>1、安装node.js<br>2、安装.NET Framework<br>3、安装对应的Appium Server版本</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>1、Java环境<br>2、Android环境<br>3、maven（利用pow.xml解决对jar包的依赖问题）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;h2 id=&quot;安装Appium&quot;&gt;&lt;a href=&quot;#安装Appium&quot; class=&quot;headerlink&quot; title=&quot;安
      
    
    </summary>
    
      <category term="软件测试" scheme="https://aoxiaodie.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Jave Web</title>
    <link href="https://aoxiaodie.github.io/2018/10/07/language/Jave-Web/"/>
    <id>https://aoxiaodie.github.io/2018/10/07/language/Jave-Web/</id>
    <published>2018-10-07T06:54:00.000Z</published>
    <updated>2018-10-07T15:47:37.030Z</updated>
    
    <content type="html"><![CDATA[<p>常见问题<br>1、Servlet的生命周期<br><br><br>2、Cookie和Session<br><br><br><br></p><h1 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h1><p>内置对象:在JSP页面中不需要定义就可以在网页中直接使用的对象。</p><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><p>获取客户端的参数和流<br><br><br><br></p><h2 id="response"><a href="#response" class="headerlink" title="response"></a>response</h2><p>客户端的响应<br><strong>重定向</strong> ：跳转到另一个页面，可以用<code>response.sendRedirect(目标页面路径)</code>来进行重定向。<br><br><br>redirect和forward的对比<br><br><br><br></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>cookie：cookie是一个小的文本数据，由服务器端生成。<br>启用后，会将这个小文本数据保存到某个目录下的文本文件内，下次登录同一网站时，客户端浏览器会自动将cookie读入并传给服务器端。<br>cookie的值一般以key-value的形式进行表达。<br>cookie不安全。</p><p>不同与cookie，session是将记录保存在服务器端。<br>对于每个session，服务器端都有一个sessionId来标识它，以此判断用户的多个页面使用的是同一个session。<br><br><br><br><br><br></p><hr><h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p><h2 id="Ico"><a href="#Ico" class="headerlink" title="Ico"></a>Ico</h2><p>Ioc，控制反转（Inversion of Control）是面向对象编程的一种设计原则，用以减低计算机代码间的耦合。其中最常见的方式是依赖注入（DI）。<br>Ico的思想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源，作为回应，容器适时的返回资源。而应用了 IOC 之后，则是容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源。这种行为也被称为查找的被动形式。</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他类中调用Book类的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServlet</span></span>&#123;</span><br><span class="line">  BookService service = Factory.getService();</span><br><span class="line">  service.addBook();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BookService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BookService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>BeanFactory: Ico容器的基本实现。<br>1.Spring中，工厂类的实现其实就是在xml文件中配置bean：<br><code>&lt;bean id=&quot;userService&quot; class=&quot;className&quot;&gt;&lt;/bean&gt;</code><br>2.实现：<br>创建一个ApplicationContext对象，它是BeanFactory的一个子接口，帮助我们在classpath路径下查找xml配置文件；<br><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xmlName&quot;)</code><br>3.最后，通过getBean(配置文件中id名称)来获取指定的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IUserService userService = (IUserService)ApplicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">userService.methodName();</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><a href="https://www.cnblogs.com/fysola/p/6361181.html" target="_blank" rel="noopener">Spring框架及简单的Demo</a><br><br><br><br><br><br></p><hr><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见问题&lt;br&gt;1、Servlet的生命周期&lt;br&gt;&lt;br&gt;&lt;br&gt;2、Cookie和Session&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;JSP内置对象&quot;&gt;&lt;a href=&quot;#JSP内置对象&quot; class=&quot;headerlink&quot; title=&quot;JSP内
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java深入学习</title>
    <link href="https://aoxiaodie.github.io/2018/08/19/language/java(deep)/"/>
    <id>https://aoxiaodie.github.io/2018/08/19/language/java(deep)/</id>
    <published>2018-08-19T08:21:17.000Z</published>
    <updated>2018-10-07T07:32:33.261Z</updated>
    
    <content type="html"><![CDATA[<p>常见问题：<br>1、final和finally和finalize<br><br><br>2、String和StringBuffer和StringBuilder<br><br><br><br><br><br></p><hr><h1 id="Java虚拟机（JVM）"><a href="#Java虚拟机（JVM）" class="headerlink" title="Java虚拟机（JVM）"></a>Java虚拟机（JVM）</h1><p>首先简单看看Java程序的运行过程：</p><blockquote><p>Java源文件——&gt;编译器——&gt;字节码文件（.class）<br>字节码文件——&gt;JVM——&gt;机器码</p></blockquote><p>字节码文件可以在任何平台通过JVM运行，所以Java是跨平台的。<br><br></p><h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><p>类加载整个生命周期：</p><blockquote><p>加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;使用——&gt;卸载</p></blockquote><h3 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h3><p>Java类加载器（Java Classloader）是Java运行时环境的一部分。负责动态加载Java类到JVM的内存空间中。</p><p>3个默认的类加载器：<br>（1）引导类加载器（Bootstrap Loader），由原生代码实现（如C）不继承java.lang.Classloader，负责加载Java核心库，存储在&lt;JAVA_HOME&gt;/jre/lib目录中；<br>（2）扩展类加载器（Extension Loader），加载Java的扩展库，父加载器是Bootstrap Loader；<br>（3）系统类加载器（System Class Loader/AppClass Loader），又称为应用类加载器，父类是Extension Loader，</p><p>类加载器就是在加载阶段启动的。<br>另外，准备阶段会为类变量（静态变量）分配内存并设置初始值，其实也就是静态变量/方法在类加载时执行。<br>如：<code>public static int i = 123</code><br>在准备阶段的初始值为0，此时仅仅分配内存空间，真正的初始化赋值在初始化阶段。</p><p>参考<a href="https://blog.csdn.net/world6/article/details/52041857" target="_blank" rel="noopener">java类的加载过程和类加载器的分析</a><br><br><br><br></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><br><br><br></p><h3 id="Java的初始化顺序"><a href="#Java的初始化顺序" class="headerlink" title="Java的初始化顺序"></a>Java的初始化顺序</h3><blockquote><p>父类静态成员初始化&gt;父类静态初始化块&gt;子类静态成员初始化&gt;子类静态初始化块&gt;父类初始化块&gt;父类构造函数&gt;子类初始化块&gt;子类构造函数</p></blockquote><p>静态初始化块<br>static初始化块在构造函数之前执行，且只执行一次，即类首次加载时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"> <span class="comment">// 初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h2><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p><a href="https://www.cnblogs.com/1024Community/p/honery.html#%E4%B8%80----%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF%E4%BD%A0%E8%A6%81%E4%BA%86%E8%A7%A3%E5%90%A7" target="_blank" rel="noopener">扒一扒JVM的垃圾回收机制</a><br><br><br><br></p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p><br><br><br><br><br></p><hr><h1 id="Java的集合框架"><a href="#Java的集合框架" class="headerlink" title="Java的集合框架"></a>Java的集合框架</h1><p><br><br><br><br><br></p><hr><h1 id="Java线程和并发"><a href="#Java线程和并发" class="headerlink" title="Java线程和并发"></a>Java线程和并发</h1><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="线程安全的集合对象："><a href="#线程安全的集合对象：" class="headerlink" title="线程安全的集合对象："></a>线程安全的集合对象：</h3><table><thead><tr><th style="text-align:center">安全</th><th style="text-align:center">不安全</th></tr></thead><tbody><tr><td style="text-align:center">Vector</td><td style="text-align:center">ArrayList</td></tr><tr><td style="text-align:center">HashTable</td><td style="text-align:center">HashMap</td></tr><tr><td style="text-align:center">StringBuffer</td><td style="text-align:center">StringBuilder</td></tr></tbody></table><blockquote><p>线程安全：多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能访问直到该线程读取完毕。</p></blockquote><p><br><br><br></p><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>1.进程是资源分配的最小单位，线程是程序执行的最小单位；<br>2.进程是用有资源的基本单位，线程是调度和分配的基本单位；<br>2.进程有自己独立的地址空间，每启动一个进程，系统就会为它分配各种资源；而线程是共享进程中的数据、使用相同的地址空间。CPU创建和切换一个线程的花费远比进程要小。<br><br><br><br></p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>同Android<br><a href="http://aoxiaodie.top/2018/05/24/Android/" target="_blank" rel="noopener">Android</a><br><br><br><br><br><br></p><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念"></a>三个概念</h3><p>1、原子性<br>2、可见性<br>3、有序性<br><br><br><br></p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>1、线程安全问题：多个线程同时访问一个资源（临界资源），导致运行结果与预期不同。<br>2、解决：序列化访问临界资源，也称同步互斥访问：</p><blockquote><p>(1)、同步代码块(synchronized)<br>(2)、同步方法(synchronized)<br>(3)、加锁(Lock)</p></blockquote><p><br><br><br></p><h3 id="一些关键字"><a href="#一些关键字" class="headerlink" title="一些关键字"></a>一些关键字</h3><p><strong>1、volatile</strong><br>修饰字段（成员变量），保证了不同线程对这个变量进行操作时的可见性。<br><br><br><strong>2、synchronized</strong><br><strong>3、wait()、notify()</strong> 继承Object类，与synchronized连用：</p><blockquote><p>调用wait()，线程进入等待状态，并释放moniter对象；<br>然后再通过notify()方法唤醒一个新的线程。</p></blockquote><p>应用：交替打印AB字母<br><br><br><strong>4、sleep()</strong> 继承自Thread类，使进程中断，但不会释放monitor对象，一定时间后自启动。<br><br><br><strong>5、ThreadLocal</strong><br>ThreadLocal是线程的局部变量，是每一个线程所单独持有的，其他线程不能对其进行访问。ThreadLocal为变量在每个线程中都创建了一个副本。</p><p>ThreadLocal解决的问题：<br>当一个对象的变量被多个线程访问时，会产生线程安全问题（可以使用synchorinized关键字来为此变量加锁，进行同步处理，但会影响程序执行效率），所以使用ThreadLocal，它会为每个使用该变量的线程提供一个独立的变量副本，当多线程访问该变量时，使用的是拷贝的变量副本。</p><p>常见的ThreadLocal使用场景：<br>数据库连接、Session管理等。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>解决Web应用中的高并发<br><br><br><br><br><br></p><hr><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><br><br><br></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>（Spring的BeanFactory,ApplicationContext）<br><br><br><br></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>（Spring AOP）<br><br><br><br></p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>（应用场景：若想对一个类从不同角度进行功能扩展，例如java.io中，InputStream是一个抽象类，标准类库中提供了FileInputStream/ByteArrayInputStream等各种不同的子类，分别从不同角度对InputStream进行了功能扩展。这些不同的实现类其构造函数的输入均为InputStream（的实现类），然后对InputStream添加不同层次的逻辑，从而实现不同的功能，这就是装饰。）<br><br><br><br></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>（各种事件监听器）<br><br><br><br></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>（Android的ListView）</p><p>-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见问题：&lt;br&gt;1、final和finally和finalize&lt;br&gt;&lt;br&gt;&lt;br&gt;2、String和StringBuffer和StringBuilder&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Java虚拟机（JVM）&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Unity的3D跑酷游戏《BraveChase》</title>
    <link href="https://aoxiaodie.github.io/2018/08/17/games-development/BraveChase/"/>
    <id>https://aoxiaodie.github.io/2018/08/17/games-development/BraveChase/</id>
    <published>2018-08-17T07:13:16.000Z</published>
    <updated>2019-02-27T08:32:23.871Z</updated>
    
    <content type="html"><![CDATA[<p>这个视频是给我麻麻过生日的时候录的，也懒得在录一般正式版的了，总之差不多。</p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"/assets/audio/ao.webm"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>主要讲一讲完成游戏的过程，因为没有系统地学过C#，所以脚本这块只能粗略地描述一番。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个视频是给我麻麻过生日的时候录的，也懒得在录一般正式版的了，总之差不多。&lt;/p&gt;
&lt;div id=&quot;dplayer1&quot; class=&quot;dplayer hexo-tag-dplayer-mark&quot; style=&quot;margin-bottom: 20px;&quot;&gt;&lt;/div&gt;&lt;sc
      
    
    </summary>
    
      <category term="游戏开发" scheme="https://aoxiaodie.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络概要</title>
    <link href="https://aoxiaodie.github.io/2018/07/05/Base/network/"/>
    <id>https://aoxiaodie.github.io/2018/07/05/Base/network/</id>
    <published>2018-07-05T02:32:56.000Z</published>
    <updated>2019-02-26T06:10:50.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><p><img src="assets/image/data/net_architecture.PNG" alt="net_architecture"><br><br></p><h2 id="TCP-IP五层体系结构"><a href="#TCP-IP五层体系结构" class="headerlink" title="TCP/IP五层体系结构"></a>TCP/IP五层体系结构</h2><p><img src="assets/image/data/net_general.PNG" alt="net_general"><br><br></p><h2 id="计算机网络概要"><a href="#计算机网络概要" class="headerlink" title="计算机网络概要"></a>计算机网络概要</h2><p><img src="assets/image/data/general.png" alt="general"><br><br><br><br></p><h2 id><a href="#" class="headerlink" title></a><br></h2><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>协议数据单元：比特<br>中间设备：转发器</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>码元：代表不同离散数值的基本波形。<br><img src="assets/image/data/Physical.png" alt="Physical"><br><br><br><br></p><h2 id="-1"><a href="#-1" class="headerlink" title></a><br></h2><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>协议数据单元：帧<br>中间设备：网桥或桥接器</p><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>1.链路：从一个结点到相邻结点的一段物理线路（有线或无线）。<br>2.数据链路：物理线路、必要的通信协议、以及实现这些协议的软件和硬件。<br>3.网络适配器：实现以上协议的软件和硬件。包括数据链路层和物理层两层的功能。</p><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><p><img src="assets/image/data/Data_Link_01.png" alt="Data_Link_01"></p><blockquote><p>1.循环冗余检验CRC：假定待传送的数据为M，长度为k个比特，CRC运算就是在M后面添加供差错检测用的n位冗余码，构成一个帧发送出去，一共发送（k+n）位。<br>n位冗余码求法：在M后面添加n个0，得到的（k+n）位数除以长度为（n+1）位的除数P，如P=1101（即n=3），得到商Q和余数R，这个R即冗余码。这种为了进行检错而添加的冗余码称为 <strong>帧检测序列FCS</strong> 。<br><br><br>2.凡是接收端数据链路层接受的帧均无差错。<br><br><br>3.数据链路层的“可靠传输”：数据链路层的发送端发送什么，在接收端就收到什么。<br>不要求数据链路层向上提供可靠传输的服务，则数据链路层协议都不是可靠传输的协议。</p></blockquote><p><br></p><h2 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h2><p><img src="assets/image/data/Data_Link_02.png" alt="Data_Link_02"></p><blockquote><p>4.PPP协议：接收方每收到一个帧，就进行CRC检验。如果CRC检验正确，就收下这个帧；反之，就丢弃这个帧，其他什么也不做。</p></blockquote><p><br></p><h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p><img src="assets/image/data/Data_Link_03.png" alt="Data_Link_02"></p><blockquote><p>5.第一，采用无连接的工作方式，即不必先建立连接就可以直接发送数据。因此，以太网提供的服务是 <strong>不可靠的交付</strong>，而是尽最大努力的交付。<br>第二，以太网发送的数据都是用曼彻斯特编码的信号。</p></blockquote><p><br></p><h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><p>1.以太网端到端往返时间2τ称为争用期，争用期又称为碰撞窗口。<br>2.通常取51.2us为争用期时间。<br>3.退避算法<br><img src="assets/image/data/algorithm.png" alt="algorithm"><br><br><br><br></p><h3 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h3><p>1.MAC层的硬件地址：<br>硬件地址又称为物理地址或MAC地址，IEEE802标准为局域网规定了一种48位的全球地址，即局域网上的每一台计算机中固化在 <strong>适配器ROM中的地址</strong>。<br>2.MAC帧的格式：<br>以太网最常用的是以太网 V2 格式的MAC帧。<br><img src="assets/image/data/MAC.png" alt="MAC"><br><br><br><br></p><h3 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h3><p>网桥——&gt;交换式集线器<br>1.网桥：对收到的帧根据MAC帧的目的地址进行转发和过滤。<br>2.交换式集线器|以太网交换机：全双工方式，并且具有并行性。</p><blockquote><p>总线以太网使用CSMA/CD协议，以半双工方式工作，而以太网交换机不使用共享总线，没有碰撞问题，所以不使用CSMA/CD协议，以全双工方式工作。</p></blockquote><p><br><br><br></p><h2 id="-2"><a href="#-2" class="headerlink" title></a><br></h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>协议数据单元：分组<br>中间设备：路由器</p><h2 id="两种服务"><a href="#两种服务" class="headerlink" title="两种服务"></a>两种服务</h2><p><img src="assets/image/data/Network_01.PNG" alt="Network_01"><br><br><br><br></p><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p><img src="assets/image/data/Network_02.PNG" alt="Network_02"><br><img src="assets/image/data/Network_03.PNG" alt="Network_03"><br><br><br><br></p><h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><p><img src="assets/image/data/Network_04.PNG" alt="Network_04"><br><br><br><br></p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>作用：为了更有效地转发IP数据报和提高交付成功的机会。</p><p>ICMP报文装在IP数据报中，属于IP层的协议。</p><p>应用举例：</p><blockquote><p>1.分组网间探测PING，用来测试两台主机间的连通性。<br>PING是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP和UDP。<br>2.traceroute，用来跟踪一个分组从源点到终点的路径。</p></blockquote><p><br><br><br></p><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><p>可以把整个互联网划分为许多较小的自治系统AS。<br>目前，一个大的ISP就是一个自治系统，互联网把路由选择协议划分成两大类：<br>1.内部网关协议IGP<br>2.外部网关协议EGP</p><h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3><p>RIP是一种分布式的基于距离向量的路由选择协议。</p><blockquote><p>“距离”也称为“跳数”，RIP允许一条路径最多只能包含15个路由器，因此距离为16即相当于不可达。所以RIP只适用于小型互联网。</p></blockquote><p><br></p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>1.仅相邻路由器交换信息；<br>2.交换的是当前路由器的全部信息，即自己现在的路由表；<br>3.按固定的时间间隔交换信息。<br><br></p><h4 id="距离向量算法："><a href="#距离向量算法：" class="headerlink" title="距离向量算法："></a>距离向量算法：</h4><p>对每一个相邻路由器发来的RIP报文：<br><img src="assets/image/data/Network_05.PNG" alt="Network_05"><br><br></p><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p>RIP协议使用运输层的用户数据报UDP进行传送。<br><br></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：实现简单，开销较小。<br>缺点：坏消息传播慢。<br><br></p><h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3><p>OSPF使用分布式链路状态协议<br><br></p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><p>1.向本自治系统中的所有路由器发送信息，使用洪泛法；<br>2.发送的消息是与本路由器相邻的所有路由器的链路状态；<br>3.只有当链路状态发送变化时，路由器才向所有路由器发送消息。</p><p>所有的路由器最终能够建立一个链路状态数据库，即全网的拓扑结构图。<br><br></p><h4 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h4><p>OSPF直接用IP数据报传送。<br><br></p><h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3><p><br><br><br></p><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><p><br><br><br></p><h2 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h2><p>本地地址：仅在本机构有效的IP地址；<br>全球地址：向互联网管理机构申请的全球唯一的IP地址。</p><p>专用地址：只能用作本地地址而不能作为全球地址。</p><blockquote><p>（1）10.0.0.0到10.255.255.255，或记为10.0.0.0/8<br>（2）172.16.0.0到172.31.255.255，或记为172.16.0.0/12<br>（3）192.168.0.0到192.168.255.255，或记为192.168.0.0/16</p></blockquote><p>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN。<br><br><br><br></p><h2 id="-3"><a href="#-3" class="headerlink" title></a><br></h2><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>运输层属于面向通信部分的最高层，同时也是用户功能的最底层。<br>只有主机的协议栈才有运输层，网络核心部分中的路由器在转发分组时都只用到下三层的功能。<br>通信的真正端点不是主机而是主机中的进程。<br><br></p><h2 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h2><p><img src="assets/image/data/transport_01.PNG" alt="transport_01"><br><br></p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p><img src="assets/image/data/transport_02.PNG" alt="transport_02"><br><br></p><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>1.停止等待：每发送完一个分组就停止发送，等待对方确认。再收到确认后再发送下一个分组。<br>2.超时重传：每发送完一个分组时设置一个超时计时器。<br>3.信道利用率：U=Td/(Td+RTT+Ta)</p><blockquote><p>Td：发送分组需要的时间<br>RTT：往返时间<br>Ta：分组长度除以数据率</p></blockquote><p>为了提高传输效率，采用流水线传输。<br><br></p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>发送方：维持发送窗口，连续发送分组，不需要等待对方确认。<br>接收方：采用累积确认的方式，对按序到达的最后一个分组发送确认。<br><br></p><h2 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h2><p><img src="assets/image/data/transport_03.PNG" alt="transport_03"></p><h3 id="TCP拥塞控制的方法"><a href="#TCP拥塞控制的方法" class="headerlink" title="TCP拥塞控制的方法"></a>TCP拥塞控制的方法</h3><p>拥塞控制窗口cwnd<br>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p><p>1.慢开始算法<br>思想：由小到大逐渐增大发送窗口，即由小到大逐渐增大拥塞窗口的数值。</p><blockquote><p><strong>拥塞窗口cwnd每次的增加量 = min(N,SMSS)</strong><br>N是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数；SMSS是最大报文段。<br>窗口大小的单位：报文段的个数。</p></blockquote><p><br><br>传输轮次：一个传输轮次所经历的时间其实就是往返时间RTT。<br>每经过一个传输轮次，拥塞窗口cwnd就加倍（指数增加）。<br><br><br>2.拥塞避免算法<br>思想：每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限状态变量ssthresh。<br>cwnd&lt;ssthresh，慢开始算法<br>cwnd&gt;ssthresh，拥塞避免算法<br>cwnd=ssthresh，皆可</p><p>发生网络拥塞时调整门限值ssthresh = cwnd/2。<br><br><br><br></p><h2 id="-4"><a href="#-4" class="headerlink" title></a><br></h2><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名系统DNS是互联网使用的命名系统，能够把互联网上的主机地址转换成IP地址。</p><h3 id="互联网的域名结构"><a href="#互联网的域名结构" class="headerlink" title="互联网的域名结构"></a>互联网的域名结构</h3><p>域名：任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</p><blockquote><p>mail.cctv.com ——&gt; 三级域名.二级域名.顶级域名<br>域名中的标号都由英文字母和数字组成，每 一个标号不超过63个字符，也不区分大小写。</p></blockquote><p><br></p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>一个服务器所负责管辖的（或有权限的）范围称为区。每一个区设置相应的权限域名服务器。<br>DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位。<br><img src="assets/image/data/application_01.PNG" alt="application_01"><br><br></p><h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2><p><img src="assets/image/data/application_02.PNG" alt="application_02"><br><br></p><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><p>简单来说就是可以在本地通过TCP远程操控另一台主机。</p><p>TELNET使用客户服务器方式，本地系统运行客户进程，远地主机运行服务器进程。<br>TELNET定义了数据和命令应怎样通过因特网，这些定义就是所谓的 <strong>网络虚拟终端NVT</strong><br><br></p><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><p>万维网是一个大规模的、联机式的信息储藏所，英文简称web。<br>万维网是一个分布式的超媒体系统，是超文本系统的扩充。</p><h3 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h3><p>1.用途：标志万维网上的各种文档，并使每一个文档在整个互联网范围内具有唯一的标识符URL。<br>2.一般形式：</p><blockquote><p>&lt;协议&gt;://&lt;主机域名&gt;:&lt;端口号&gt;/&lt;路径&gt;</p></blockquote><p><br></p><h3 id="超文本传送协议HTTP"><a href="#超文本传送协议HTTP" class="headerlink" title="超文本传送协议HTTP"></a>超文本传送协议HTTP</h3><p>HTTP默认端口号为80，可省略。</p><p>特点：<br>1.使用TCP连接传送，保证数据的可靠传输；<br>2.HTTP协议本身是无连接的；<br>3.HTTP协议是无状态的，客户第二次访问时的响应时间与第一次相同。<br><br></p><h3 id="信息检索系统"><a href="#信息检索系统" class="headerlink" title="信息检索系统"></a>信息检索系统</h3><p>1.全文检索搜索：从已经建立的索引数据库中查询。</p><blockquote><p>谷歌、必应、百度</p></blockquote><p>2.分类目录搜索：</p><blockquote><p>雅虎、新浪、搜狐、网易</p></blockquote><p><br></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>三个主要组成构件：<br>1.用户代理UA：电子邮件客户端软件<br>2.邮件服务器<br>3.邮件发送协议SMTP和邮件读取协议POP3<br><br></p><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>为了让协议软件通用且便于移植，将协议软件参数化。<br>给这些参数赋值的动作叫做协议配置。<br><br><br><br></p><h2 id="-5"><a href="#-5" class="headerlink" title></a><br></h2><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h2><h3 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h3><p>即加密密钥和解密密钥使用相同的密码体制，保密性仅取决于密钥的保密，而算法是公开的。<br>密钥占64位（实际密钥长度为56位，外加8位用于奇偶校验）。</p><p>数据加密标准DES属于对称密钥密码体制。<br><br></p><h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>使用不同的加密密钥和解密密钥，加密密钥（即公钥）是公开的，而解密密钥（即私钥或秘钥）是保密的，加密算法和解密算法都是公开的。</p><p>-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;h2 id=&quot;网络层次划分&quot;&gt;&lt;a href=&quot;#网络层次划分&quot; class=&quot;headerlink&quot; title=&quot;网络层次划分&quot;&gt;&lt;/a&gt;网
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://aoxiaodie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>全是言情</title>
    <link href="https://aoxiaodie.github.io/2018/06/22/essay/story/"/>
    <id>https://aoxiaodie.github.io/2018/06/22/essay/story/</id>
    <published>2018-06-22T10:02:07.000Z</published>
    <updated>2018-07-01T15:41:28.828Z</updated>
    
    <content type="html"><![CDATA[<p>最近的状态：<br>不喜欢虐恋，不喜欢超长篇。<br>推的文章有最近看过，也有以前看过印象比较深刻的，每个系列倒序来更。</p><p>实在太懒了，就随便写写。</p><h1 id="穿书文"><a href="#穿书文" class="headerlink" title="穿书文"></a>穿书文</h1><h2 id="《哥哥太好了怎么办》"><a href="#《哥哥太好了怎么办》" class="headerlink" title="《哥哥太好了怎么办》"></a>《哥哥太好了怎么办》</h2><blockquote><p>1.作者：十六月西瓜<br>2.简介：《强制爱》中，女配霍妩是鸠占鹊巢了十八年的假公主。而她所拥有的这一切，原本都该是属于女主的。一次意外，霍妩的真正身世曝光。她和女主各归其位，但她还是被女主视为了眼中钉，肉中刺。最后落得了一个凄惨的下场。<br>十八线小明星霍妩穿成了书中的同名女配后，瑟瑟发抖。女主战斗力太强，惹不起惹不起。为了避免书中的结局，她抱紧了自家“亲大哥”的大腿，以求庇护。金大腿格外粗壮，这位顶配的“亲大哥”更是强大到无所不能。<br>但是…… 怎么抱着抱着，就不让松开了？<br>QAQ - 霍妩眨眨眼，“如果你真是我哥哥就好啦。”<br>霍屿森淡淡拒绝，“不，我只想做你男人。”<br>大哥对我太好了怎么办？ 还能怎么办，当然是在一起啊。</p></blockquote><p><br><br>伪兄妹文，超喜欢！<br><br><br><br></p><h2 id="《每次都死在男主怀里》"><a href="#《每次都死在男主怀里》" class="headerlink" title="《每次都死在男主怀里》"></a>《每次都死在男主怀里》</h2><blockquote><p>1.作者：姜之鱼<br>2.简介：风水灵异捉鬼小说《豪门鬼少》里，男主时戚心狠手辣，宁檬死后穿成他身边的人<br>第一次，男主 7岁，她穿成了偏心狠毒的老太太<br>第二次，男主17岁，她穿成了见钱眼开的女同桌<br>第三次，男主21岁，她穿成了他口是心非的情敌<br>第四次，她自己整个人穿进了小说里<br>时戚小时候有个偷偷藏起来的小日记本，记录了他奶奶的怪癖。<br>后来他看见，那个对他好的不是真奶奶，而是只附身的野鬼。</p></blockquote><p><br><br>男强女弱。<br><br><br><br></p><h2 id="《这剧情有问题》"><a href="#《这剧情有问题》" class="headerlink" title="《这剧情有问题》"></a>《这剧情有问题》</h2><blockquote><p>1.作者：锡纸锦鳞<br>2.简介：米媚一觉醒来，发现自己穿越到了一本狗血小说里。<br>白富美，娇纵虚荣，任性恶毒，使计与总裁订婚一年，目前发生情感危机，危机源直指总裁公司实习秘书……<br>这熟悉的设定，尼玛妥妥的炮灰本pao！<br>卷好铺盖准备逃走的米媚忽然一阵心悸倒地，脑海中大写加粗：目标OOC！！！<br>荆泓轩一个健步冲到她身边熟练地喂药揉胸满脸担忧。<br>米媚虚弱地倒在总裁怀里：“这剧情，有问题！”</p></blockquote><p><br><br><br></p><h2 id="《抱错金大腿》"><a href="#《抱错金大腿》" class="headerlink" title="《抱错金大腿》"></a>《抱错金大腿》</h2><blockquote><p>1.作者：瀛之<br>2.简介：女主版：顾双双穿进一本名为《霸王》的修真小说中。知道剧情当然要“抱”紧金大腿，然后伺机抢夺机缘走上人生巅峰赢家。我“抱”金大腿的方式有误？为什么狂霸酷炫拽的男主被反派大死角碾压？这剧情是怎么了！<br>男主版：从死亡后浴火重生，我要欺我、弃我、伤我者不得好死。这是一个螳螂捕蝉黄雀在后的故事。<br>顾双双：剧情在手，机缘我有，修真大道何惧之有？沈剑：呵呵</p></blockquote><p><br><br>男女主相爱以后也太甜了吧！<br><br><br><br></p><h2 id="《我真不是女主》"><a href="#《我真不是女主》" class="headerlink" title="《我真不是女主》"></a>《我真不是女主》</h2><blockquote><p>1.作者：曲小蛐<br>2.简介：叶语穿进了一本修真小说里。<br>还穿了两次。<br>二穿后，她成了书里的恶毒女配。<br>为避免悲惨下场，叶语决定躲开魔帝男主。<br>只是她穿来的时间点有些尴尬……<br>于是，叶语魂穿的第二天，全魔域都传开了一个消息——<br>魔帝昨晚新婚大典，被魔妾一脚踹出了寝宫。<br>众魔臣：这得技术多烂啊？<br>魔帝：……<br>后来。<br>叶语：别过来！——我真不是女主，男主你特么认错人了！</p></blockquote><p><br><br><br></p><h2 id><a href="#" class="headerlink" title></a><br></h2><h1 id="仙侠-修仙-玄幻-灵异"><a href="#仙侠-修仙-玄幻-灵异" class="headerlink" title="仙侠/修仙/玄幻/灵异"></a>仙侠/修仙/玄幻/灵异</h1><h2 id="修仙"><a href="#修仙" class="headerlink" title="修仙"></a>修仙</h2><h3 id="《勿扰飞升》"><a href="#《勿扰飞升》" class="headerlink" title="《勿扰飞升》"></a>《勿扰飞升》</h3><blockquote><p>1.作者：月下蝶影<br>2.简介：当箜篌踏上修仙之路，她才知道，仙侠话本里都是骗人的。掉崖没有修真秘籍，更没有美人。<br>但是，她觉得自己一定有话本主角一样的实力与运气！</p></blockquote><p><br><br>年纪大了，就喜欢看一些轻松小甜文，比如这本。<br>这不是一本主流的修仙文，文章写得很温馨，看过作者的另外几篇文，大多是这种风格，<br>并且喜欢用“xx大概理解xx为什么这样好”之类的语句，哈哈。<br>很喜欢男女主间的感情线，男主特别萌，反差萌。</p><p>另外再推一本这个作者写的《如珠似玉》，书荒的时候可以看看。<br><br><br><br><br><br></p><h2 id="玄幻"><a href="#玄幻" class="headerlink" title="玄幻"></a>玄幻</h2><h3 id="《司命》"><a href="#《司命》" class="headerlink" title="《司命》"></a>《司命》</h3><blockquote><p>1.作者：九鹭非香<br>2.简介：三界外，上有万天之墟，下有无极荒城。皆是无日月、无生灵的死寂之地。有进无出。<br>而这万天之墟乃是囚龙之地。<br>囚了这世间最后一条龙。<br>九重天上的司命星君表白被拒，酒后入梦，无意中入了万天之墟，遇到了神龙长渊。<br>从此，这世间少了一个司命星君，多了一个孤儿尔笙。<br>“美人芳名？”<br>“吾名长渊。”<br>“长渊家住何方？家中可有妻室？”<br>“你待如何？”<br>尔笙从衣袖里掏出一把做工拙劣的短剑，递给长渊，郑重道：“自剑。”<br>应该是自荐吧……<br>长渊默了默，没敢接过那柄剑。尔笙忽悠道：“此乃我祖上留下来的传家之宝，我自愿献上此剑，呃……那啥来着，嗯，与你共组一个家庭，共生一堆小屁孩。”</p></blockquote><p><br><br>稍早之前看的，但是印象里是一本不错的小说。<br>男女主间的感情戏也写得很好，男主忠犬且蠢萌。<br><br><br><br></p><h3 id="《魔尊》（出版名《苍兰诀》）"><a href="#《魔尊》（出版名《苍兰诀》）" class="headerlink" title="《魔尊》（出版名《苍兰诀》）"></a>《魔尊》（出版名《苍兰诀》）</h3><blockquote><p>1.作者：九鹭非香<br>2.简介：历经千般辛苦万般算计，魔界的人终于把死在上古的魔尊复活了。<br>　　魔界的人指望他带领他们打上天界、翻身做主、统领五行三界<br>　　但是他们却渐渐发现，他们想错了<br>　　这个昔日魔尊不怒自威没错，有无边神力没错，但他……<br>　　好像是个神经病啊……<br>　　不时朝令夕改，偶尔颠三倒四也就罢了<br>　　这成日成夜神神叨叨嘀嘀咕咕自言自语的又是什么毛病！<br>　　小兰：“他没病，他就是贱……见不得人好。”<br>　　东方：“我只是见不得你好。”<br>　　小兰：“……”</p></blockquote><p><br><br>挺喜欢九鹭非香的文，反正每次书荒就会把某个作者所有的文看完。<br>怎么说呢，算是一篇甜中带星点玻璃渣的文吧。<br>前面部分男女主共用一个身体时还是很搞笑的，后面部分有点啼笑皆非的感觉。<br><br><br><br></p><h3 id="《三千鸦杀》"><a href="#《三千鸦杀》" class="headerlink" title="《三千鸦杀》"></a>《三千鸦杀》</h3><blockquote><p>1.作者：十四郎<br>2.简介：朝阳台上，帝姬一曲东风桃花，艳绝天下。<br>而一场琉璃火，让世上再无大燕国，前尘往事如梦过。隐姓埋名的帝姬潜伏在修仙之地香取山成了小杂役覃川，不意故人纷纷粉墨登场，以前的恋人左紫辰失了记忆与玄珠相依相偎，而横地里跳出来个风流倜傥玉树临风的傅九云，对她诸多刁难百般挑逗，真假难分，恩宠难受。趁着白河龙王在香取山作乱，覃川盗了山主的宝物，扬长而去。此时自知受到欺骗的傅九云勃然大怒，不远万里追上她。得知她的使命后，无法阻止，只能用自己的生命去成全。而她不知道，为了遇见她，他已经独自守望千年。<br>这十生十世的夙愿，牵绊，情缘，历尽劫波，是换来他和她今生今世的永不分离，还是忘川边上奈何桥前的相见无期？</p></blockquote><p><br><br>好几年以前看的，记录在我的便签里很久了，应该是不错的。<br><br><br><br></p><h3 id="《半城风月》"><a href="#《半城风月》" class="headerlink" title="《半城风月》"></a>《半城风月》</h3><blockquote><p>1.作者：十四郎<br>2.简介：她来自钟山之巅，披霜带雪，清艳无双，于“情”之一事，偏又没什么天赋，生平最喜不过清茶一杯，看看热闹。<br>都说她年少多舛，性格古怪，其实她也可以乖巧柔顺，笑靥如花。<br>都说她毒舌刻薄，傲慢无礼，其实她也可以巧笑倩兮，温柔可亲。<br>不过——<br>她·就·是·不·乐·意！<br>直到那天，她遇见了一个少年。<br>半城风月半城雪，她一生中的所有风景，都因他而辉煌了起来。</p></blockquote><p><br><br><br></p><h3 id="《护心》"><a href="#《护心》" class="headerlink" title="《护心》"></a>《护心》</h3><blockquote><p>1.作者：九鹭非香<br>2.简介：二十年前，天曜被心爱之人广寒门门主素影抽筋剥骨，并以五行之力封印于四方。<br>机缘巧合之中，天曜灵魂于十年前逃出封印，他感知一山村湖水中封印着他的龙骨，便附上一夭折男童之身，伺机取回龙骨。<br>雁回的出现，让天曜看见了希望。原本她心中因带有他的护心麟而心怀龙血，能助他破开封印。于是天曜开始利用雁回，让她帮他寻回身体的其他部分。<br>雁回意图逃离天曜，但两人不仅没能分开，关系反而越来越紧密，天曜被雁回数次拼死相救的义气所感动，雁回也在不断被牵扯出的事件当中发现天曜与自己斩不断的关系。<br>自己心口护心鳞的来历，师父凌霄与素影的关系……扑朔迷离的谜团接踵而来……</p></blockquote><p><br><br><br></p><h2 id="灵异"><a href="#灵异" class="headerlink" title="灵异"></a>灵异</h2><h3 id="《我在聊斋当鬼的日子》"><a href="#《我在聊斋当鬼的日子》" class="headerlink" title="《我在聊斋当鬼的日子》"></a>《我在聊斋当鬼的日子》</h3><blockquote><p>1.作者：秋水晴<br>2.简介：夏安浅掉到了聊斋世界，还很悲催地成为了地缚灵。虽然被困在白水河不能离开，但住在河边不仅能捡到萌萌的小正太，还能和妖艳无双的妖精当邻居，夏安浅觉得也挺好的。<br>路经此地的鬼使大人见到了夏安浅，觉得十分意外：她竟然不怕他？<br>于是自诩帅得狂放不羁的鬼使大人随口问道：“你知道黑无常吗？”<br>夏安浅：“知道，听说他是个凶神恶煞的矮胖子。”<br>鬼使大人：“……”</p></blockquote><p><br><br>主要还是写鬼，就归到灵异里吧。<br>介绍说是《聊斋》同人，不过我没看完过《聊斋》，对里面的故事也不甚了解。<br>小说跟聊斋一样分了好几个小故事，不过小故事里的全是小配角，主线还是男女主。<br>男主是冥界的黑无常，哈哈哈，和女主的互动什么都很萌。<br>另外，跟在女主身边的安风可以说非常萌了。<br><br><br><br></p><h2 id="道姑"><a href="#道姑" class="headerlink" title="道姑"></a>道姑</h2><h3 id="《花重锦官城》"><a href="#《花重锦官城》" class="headerlink" title="《花重锦官城》"></a>《花重锦官城》</h3><blockquote><p>1.作者：凝陇<br>2.简介：长安街头巷尾的各类诡异故事，全文分为六卷：“山祟”，“美人蛊”，“还珠记”，“金镶玉”，“桃花劫”，“龙鳞”，一卷一个妖怪或鬼物。男主是闷骚世子，女主是貌美（俗家）小道姑。<br>文名虽叫花重锦官城，但与成都无关。本文虽然参考了唐朝背景，但整体来说是个架空的朝代，所以切莫当真…</p></blockquote><p><br><br>女主是道姑，所以我强行给它分了一个类。<br>题材和故事都很新颖，前半部分写得比较好看，但是后半部分男女主的感情线稍微有点俗套。<br>另外这个作者还有一本《鹿门歌》，写的是身为锦衣卫的男主押送已是罪臣之女的女主回京路上发生的种种事情。书荒的时候可以看看吧。<br><br><br><br></p><h2 id="-1"><a href="#-1" class="headerlink" title></a><br></h2><h1 id="武侠"><a href="#武侠" class="headerlink" title="武侠"></a>武侠</h1><h2 id="《有匪》"><a href="#《有匪》" class="headerlink" title="《有匪》"></a>《有匪》</h2><blockquote><p>1.作者：priest<br>2.简介：“终有一天，你会跨过静谧无声的洗墨江，离开群山环抱的旧桃源，来到无边阴霾的夜空之下。你会目睹无数不可攀爬之山相继倾覆，不可逾越之海干涸成田，你要记得，你的命运悬在刀尖上，而刀尖须得永远向前。”<br>“愿你在冷铁卷刃前，得以窥见天光。”</p></blockquote><p><br><br>大半年没看小说了，前段时间快做完期末项目的时候闲来看推书贴，看到很多人推这本书，结果看完以后又陷入小说无法自拔。<br>《有匪》，个人感觉是一本偏故事情节的书，男女主的感情写得比较克制，从头到尾只有一个浅浅的吻。<br>不过这不影响我觉得它很好，从女主的一路成长，刻画了许多栩栩如生的人物，即使是配角，也能让人印象深刻。<br><br><br><br></p><h2 id="《长书剑》"><a href="#《长书剑》" class="headerlink" title="《长书剑》"></a>《长书剑》</h2><blockquote><p>1.作者：翔子<br>2.简介：他道：“别人都当她争名夺利，一心为己，我却知道她此生所欲所想，不过是铸得一把绝世好剑罢了……愿以毕生之力，助她完成这一心愿！”<br>“剑灵啊剑灵！她穷尽心力铸造了你，你可能告诉我，如今她芳灵何在？今生今世，可有再相聚的一天？”</p></blockquote><p><br><br>带玻璃渣的。<br>女主是一名铸剑师，一心只想铸出一把绝世好剑。<br>前期女主被误会以及最后为了铸剑差点殒命稍微有点虐以外，其他都还好。<br><br><br><br></p><h2 id="《斩春》"><a href="#《斩春》" class="headerlink" title="《斩春》"></a>《斩春》</h2><blockquote><p>1.作者：十四郎<br>2.简介：年少不知愁，她的心喜欢飞很高，望过重重山峦，在风云诡谲的江湖里，有一个梦。<br>不怕吃苦、不怕流血，要继承闻名天下的斩春剑，她总是把儿女情长丢在身后，碰也不碰。<br>直到真正失去那个可贵少年，她才明白破碎的不光是江湖梦，还有一颗年少的心。<br>原来年少时会爱上的人，可以记一辈子。<br>这世上，有两件事总教人唏嘘不已：美人迟暮，英雄末路。<br>是抛却一切伤感，与风流江湖浪人携手而归，做一对抢钱夫妻？还是珍藏年少记忆，就此千山暮雪，只影向谁去？</p></blockquote><p><br><br><br></p><h2 id="-2"><a href="#-2" class="headerlink" title></a><br></h2><h1 id="重生-宅斗"><a href="#重生-宅斗" class="headerlink" title="重生/宅斗"></a>重生/宅斗</h1><p>我有一个不太好的习惯，倘若看完某本很好看的小说，就忍不住要继续看这个类型的小说。<br>以至于我追过很长一段时间的重生宅斗文，也追过很长一段时间的推理言情文。<br><br></p><h2 id="现代重生复仇文"><a href="#现代重生复仇文" class="headerlink" title="现代重生复仇文"></a>现代重生复仇文</h2><p>我看的第一本现代重生复仇文是《重生豪门千金》，听名字挺俗的，当时书荒就看了看，其实剧情什么还是不错的，emmmmm，后来我才知道还拍成了电视剧，叫《千金归来》。<br>玖月晞有一个系列全是这个类型的小说，金手指、大爽文，心情不好的时候可以看看。<br><br><br><br></p><h2 id="古言重生"><a href="#古言重生" class="headerlink" title="古言重生"></a>古言重生</h2><h3 id="《掌珠》"><a href="#《掌珠》" class="headerlink" title="《掌珠》"></a>《掌珠》</h3><blockquote><p>1.作者：意迟迟<br>2.简介：满京城都知道，连家二房的大姑娘若生脸盲得厉害。<br>今儿梳个堕马髻她认得你，赶明儿另梳个，她就记不得了。<br>但有一位，裹成熊，她也总一眼就能分辨。<br>因为他们初见于彼时最狼狈不堪的时候，却重逢于最好的年华……</p></blockquote><p><br><br>女主是脸盲，前世临时前遇到身负重伤命不久矣的男主，所以认得男主。<br>书里的亲情和爱情都写得特别美好。<br>男女主间的感情水到渠成。<br><br><br><br></p><h2 id="重生宅斗"><a href="#重生宅斗" class="headerlink" title="重生宅斗"></a>重生宅斗</h2><h3 id="《嫡谋》"><a href="#《嫡谋》" class="headerlink" title="《嫡谋》"></a>《嫡谋》</h3><blockquote><p>1.作者：面北眉南<br>2.简介：前一世，所谓的血脉至亲告诉她，能为家族利益献身是她身为任家女子一生最大的荣耀。<br>结果她与姐姐反目成仇，让母亲垂泪早逝，累父亲血溅箭下。 [3]<br>重生于幼学之年，她再不是那任人摆布的棋子！<br>心怀鬼胎的姨娘，狼心狗肺的长辈，咄咄逼人的外敌，朝堂暗处的冷箭……<br>且看她如何谋算人心，一一揭去他们的画皮，灭之于无形！<br>所谓荣耀，是守护所爱至亲一生平安顺遂。</p></blockquote><p><br><br>女主前世为人所害、被家族抛弃，重生归来后决定守护家人，带亲人脱离家族、帮助外祖一家重获荣耀，顺便遇上了药罐子男主。<br>宅斗情节和男女主感情戏都写得挺好的。<br><br><br><br></p><h3 id="《嫡策》"><a href="#《嫡策》" class="headerlink" title="《嫡策》"></a>《嫡策》</h3><blockquote><p>1.作者：董无渊<br>2.简介：死去活来重生之后,对于前世,若要问贺行昭最舍不得什么,她大概会说舍不得女儿惠姐儿,早夭的儿子欢哥儿,还有那个敢爱敢恨的自己。</p></blockquote><p>跟上面那个名字很像呢，不过好像风格差挺多的，太久之前看的，具体情节都忘了。<br><br><br><br></p><h3 id="《嫡女策》"><a href="#《嫡女策》" class="headerlink" title="《嫡女策》"></a>《嫡女策》</h3><blockquote><p>1.作者：西兰<br>2.简介：董家嫡出大小姐，董风荷，董家这一辈唯一的嫡系，却不受祖母喜欢，不遭父亲待见。<br>母亲董夫人重病缠身，卧床十载，犹如冷宫。<br>庶妹骂她是野种，姨娘撺掇着祖母将她许给京城出了名的纨绔子弟——庄郡王府杭家的四少爷。这一切，她从来都云淡风轻，只想与母亲平淡度日。<br>不过，她也不是那等任人欺凌的主，你们既然越过了她的底线，就别怪她雷霆手段，翻脸不认人。若当她是好欺负的，就错了。<br>一日入王府，从此后风云变幻，她已不能只为自己活。<br>克妻克子、游手好闲、吃喝嫖赌、宠妾成群，这些标签，都属于她的夫君。新婚夜，妾室有孕，夫君弃她而去；第二日，有心人寻事，夫君醉酒而归；回门日，夫君居然替她在娘家撑足了脸面。这个男人，她看不透。<br>上，她要斗王妃，斗王爷，斗各房叔叔婶婶；<br>中，她要斗夫君，斗妯娌，斗围绕她夫君的莺莺燕燕；<br>下，她要斗姨娘，斗丫鬟，斗各路的管事。<br>让我们拭目以待，看这支风中清荷如何在诡谲多变、阴谋环绕的大家族里站稳脚跟，赢得夫君的倾心爱恋，成为王府当之无愧的新主母。<br>本文种田、宅斗、女强、正剧，结构复杂，人物繁多。</p></blockquote><p><br><br>这个套路好像有点老，不过还是可以看看的。<br><br><br><br></p><h3 id="《九重紫》"><a href="#《九重紫》" class="headerlink" title="《九重紫》"></a>《九重紫》</h3><blockquote><p>1.作者：吱吱<br>2.简介：窦昭觉得自己可能活不长了。<br>她这些日子总梦见自己回到了小时候，坐在开满了紫藤花的花架子下摆动着两条肥肥的小腿，白白胖胖像馒头似的乳娘正喂她吃饭……可当她真的回到小时候，人生又会<br>九重紫<br>九重紫<br>有怎样的不同呢？<br>窦昭得了一场大病，当她在一个又一个要将她带去死亡的梦境中猛地醒来时，她发现一个又一个悲剧不断上演。母亲去世前的秘密，新来继母柔弱外表下的假装，甚至她都不知道父亲是何时要将她嫁到宫里面去的！这是生她养她的家吗？是爱她的父亲吗？窦昭迷茫了，不知道什么才是真相……<br>《九重紫》，讲述一个重生的故事！</p></blockquote><p><br><br><br></p><h3 id="《十八钗》"><a href="#《十八钗》" class="headerlink" title="《十八钗》"></a>《十八钗》</h3><blockquote><p>1.作者：暮兰舟<br>2.简介：《十八钗》上卷文案：<br>　　重生在盛世燕京，颜睡莲手上是一把烂牌：祖母不慈，生母不在，<br>　　父亲不怜，继母不爱。<br>　　姐妹不悌，家奴不敬，<br>　　亲戚难缠，各怀鬼胎。<br>　　如何应对？颜睡莲说：<br>　　不急不急，先洗洗睡！<br>　　以退为进，步步为营，<br>　　徐而图之，云开月明。<br>　　《十八钗》下卷文案：<br>　　从重归燕京的顺平伯夫人、到运筹帷幄的顺平侯夫人，到声名显赫的顺平公夫人，最后成为燕京传奇的顺平公太夫人，颜睡莲再次从荆棘丛里艰难的踏出一条路，只是这一次，她不再是一个人。<br>　　若干年后，那个人突然回光返照似的抓住她的手，说：“我要先去投胎了，等你当够了太夫人，就赶紧去找我——千万不要像这辈子似的，让我一个人寂寞太久……。”<br>　　那一刻，颜睡莲在属于她的故事里，流下那个人的眼泪。<br>　　佛说：注定让一生改变的，只在百年后，那一朵花开的时间。</p></blockquote><p><br><br>前面写得好好的，后面女主开始疯狂生孩子的时候我就有点崩溃了。<br><br><br><br></p><h3 id="《表妹难为》"><a href="#《表妹难为》" class="headerlink" title="《表妹难为》"></a>《表妹难为》</h3><blockquote><p>1.作者：朱砂<br>2.简介：在很多很多文里，都有一位讨嫌的表小姐。她父母双亡寄人篱下，生活水平取决于舅父舅母的良善程度；她姿色不错颇有才华，必定会与表哥进行一场缠缠绵绵的恋爱，至于成功与否，取决于她是女主还是女配。苏浅曾经在写小说的时候，千万遍地折腾过这些表小姐们，甚至在穿越之后，她也丝毫没有危机感。结果，有一天她忽然从“大小姐”变成了“表小姐”，才发现这条路，当真是难走得很。</p></blockquote><p><br><br><br></p><h3 id="《忽如一夜病娇来》"><a href="#《忽如一夜病娇来》" class="headerlink" title="《忽如一夜病娇来》"></a>《忽如一夜病娇来》</h3><blockquote><p>1.作者：风流书呆<br>2.简介：两家人抱错孩子，一户商家，一户侯府，地位千差万别。虞襄很不幸穿成了被抱到侯府的商家女，一来就身世曝光，双腿残废，脑袋上还顶着个“丧门星”的称号。无奈之下只得牢牢抱住侯爷哥哥的大腿，先把日子混下去，等正主儿回来就麻溜的让位。几年之后正主儿回归，虞襄包袱款款准备走人，却发现抱大腿的技术太专业，侯爷哥哥不让走了！侯爷把酒掩笑：千娇万宠养大的童养媳，岂能说走就走？</p></blockquote><p><br><br>伪兄妹文！最近超喜欢，哈哈哈！<br>不过对男主的母亲和妹妹的人设表示接受无能。<br>另外这个算穿越文，懒得分类了先放在这里。<br><br><br><br></p><h3 id="《锦绣嫡女》"><a href="#《锦绣嫡女》" class="headerlink" title="《锦绣嫡女》"></a>《锦绣嫡女》</h3><blockquote><p>1.作者：醉疯魔<br>2.简介：当表姐出现在眼前，巧笑嫣然的告诉她：“你不是说绝不为妾么，现在跪在这里，不是还得叫我一声主母！”<br>　　——宁为寒门妻，不做高门妾！<br>云卿怎么都没有想到，只为这一句话，引来表姐处心积虑的谋害，联合他人灭她满门，夺她正室之位。当父母被斩，家门被灭之时，她才知道，这世人眼中美好的姻缘，不过是一片假象，他们心心念念的都是她沈家巨富的家产。<br>再次睁眼，却回到父母皆在的十三岁，她还是沈府千金嫡女，一切都还没有发生。<br>护父母，保家业。为了不重蹈覆辙，她开始步步算计。为了家人的安危，她开始狠下心肠。<br>这一世她一定要不枉此生，斗姨娘，斗姐妹，斗舅母，誓将一切牛鬼蛇神全部打倒，活出一个锦绣人生。</p></blockquote><p><br><br>应该算宅斗描写比较多的吧。<br>我记得当时看文的时候，还看过一些类似种田文的文，一般男主一直到后半部分才出现。<br><br><br><br></p><h3 id="《叶底青梅》"><a href="#《叶底青梅》" class="headerlink" title="《叶底青梅》"></a>《叶底青梅》</h3><blockquote><p>1.作者：七合香<br>2.简介：当她是江阳公主的时候，她以为她算得上十分了解叶少钧的人了。<br>好歹也是青梅竹马呢！<br>当她成为谢纨纨后，叶少钧怎么就好像变了个人似的？<br>说好的青梅竹马呢？</p></blockquote><p><br><br>高穿低的文。<br><br><br><br></p><h3 id="《重生名门望族》"><a href="#《重生名门望族》" class="headerlink" title="《重生名门望族》"></a>《重生名门望族》</h3><blockquote><p>1.作者：素素雪<br>简介：“当初我已放弃和他的婚约，你大可嫁他为妻，为何还要毁我清白？！”<br>“怨只怨妹妹这绝世的才貌，夫君满心都是你，若你嫁于旁人，夫君还不得记挂妹妹一生一世？毁你清白，令你不得不委身做妾，从此你再非夫君心心念念的那清傲首辅嫡女，只能是呼之则来挥之即去的贱妾！呵呵，只有这样姐姐才能将你从夫君心里连根拔除，你腾出位置，姐姐才能占据他的心啊…”<br>“武安侯，呵，这男人已是我用废用厌了的，姐姐稀罕扔给你便是！”<br>她读万卷书却忘了温和是为掩盖深埋的算计和阴谋；慈爱也可以是放纵、放任，娇宠无度更可以是教唆谋害；良善的外表下居然可以隐藏着怨毒、嫉恨的心！<br>本是首辅嫡亲孙女，是皇帝御口盛赞的清贵名媛，然命途多舛，父母早亡，一朝祖父过世，十岁贵女携幼弟寄养族中，自此明珠投暗…<br>幼弟被害，家产归族，成为绝户孤女他们却还不放过！谋夺了她指腹为婚的夫婿，却依旧要毁她清白，清贵名媛竟成侯门妾室，恨恨恨！<br>此仇不报意难平，贱妾之身翻手间竟令鼎盛侯门一夜灭门却也葬送了卿卿性命。闭眼睁眼间竟得重生，回到六年前。都说世上没有后悔药，她既得之，不求凤鸣九天，只愿今生再无悔！</p></blockquote><p><br><br>男女主的感情写得比较多。<br><br><br><br></p><h2 id="-3"><a href="#-3" class="headerlink" title></a><br></h2><h1 id="推理言情"><a href="#推理言情" class="headerlink" title="推理言情"></a>推理言情</h1><h2 id="现代推理言情"><a href="#现代推理言情" class="headerlink" title="现代推理言情"></a>现代推理言情</h2><p>推烂了的丁墨的《如果蜗牛有爱情》、《他来了，请闭眼》、《美人为馅》，<br>还有玖月晞的《亲爱的弗洛伊德》、《亲爱的阿基米德》、《因为风就在那里》等等。<br>最喜欢亲爱的弗洛伊德，阿基米德有点虐，《亲爱的苏格拉底》看文案觉得太虐了所以放弃。<br>其实相比之下，我更喜欢玖月晞一些。<br><br><br><br></p><h2 id="古言推理"><a href="#古言推理" class="headerlink" title="古言推理"></a>古言推理</h2><h3 id="《簪中录》"><a href="#《簪中录》" class="headerlink" title="《簪中录》"></a>《簪中录》</h3><blockquote><p>1.作者：侧侧轻寒<br>2.简介：唐朝懿宗年间, 名闻天下的女探黄梓瑕混迹于皇子之中身背谋害全家罪名的破案，遇到玉树临风却遭受诅咒，怀疑王妃真假的宫廷王爷时；当他送给她的那支断案惯用的精致玉簪 ，一步步置他安静游动却食人鲜血的小红鱼于死地时；怨憎恨、爱离别、求不得。<br>在风起长安的段段情谜中，书中描写了女神探黄梓瑕眼中的大唐社会风情长卷，从被人诬陷的罪犯到夔王府的太监，通过调查案情终于洗清冤屈成为了夔王妃的曲折离奇经历。</p></blockquote><p><br><br>我心中的白月光、朱砂痣。</p><h3 id="《大唐女法医》"><a href="#《大唐女法医》" class="headerlink" title="《大唐女法医》"></a>《大唐女法医》</h3><blockquote><p>1.作者：袖唐<br>2.简介：处境艰难，不喜吟风弄月，不会轻歌曼舞，不爱琴棋书画，<br>没情趣，只有一身医术，只会验尸解剖，不管是现代还是古代，<br>冉颜在婚姻上都显得如此没市场。<br>但怪才总有一种执拗，她偏就要在盛世大唐寻个如意郎君，<br>偏就要妥妥的嫁出去，虽然……道阻且长……且看她：<br>凰吐流苏带晚霞，覆轻纱，入侯家。<br>常自袖手，落花闲煮茶。<br>挑灯入夜看烟花，回首处，俱繁华。</p></blockquote><p><br><br><br></p><h3 id="《一品仵作》"><a href="#《一品仵作》" class="headerlink" title="《一品仵作》"></a>《一品仵作》</h3><blockquote><p>1.作者：凤今<br>2.简介：大兴元隆年间，帝君昏聩，五胡犯边。暮青南下汴河，寻杀父元凶，选行宫男妃，刺大兴帝君！<br>男妃行事成迷，帝君身手奇诡，杀父元凶究竟何人？行军途中内奸暗藏，大漠地宫机关深诡，议和使节半路身亡，盛京惊现真假勒丹王……<br>是谁以天下为局谱一手乱世的棋，是谁以刀刃为弦奏一首盛世的曲？<br>自边关至盛京，自民间至朝堂，且看一出扑朔迷离的大戏，且听一曲女仵作的盛世传奇。</p></blockquote><p><br><br>我不会告诉你，我追了两年，现在还在连载！<br><br><br><br></p><h2 id="-4"><a href="#-4" class="headerlink" title></a><br></h2><h1 id="纯古言"><a href="#纯古言" class="headerlink" title="纯古言"></a>纯古言</h1><p>顾了之的《我家竹马是太孙》、《怎敌他晚来疯急》、《咬定卿卿不放松》都还行。<br><br><br><br></p><h2 id="-5"><a href="#-5" class="headerlink" title></a><br></h2><h1 id="外星文"><a href="#外星文" class="headerlink" title="外星文"></a>外星文</h1><h2 id="《他与月光为邻》"><a href="#《他与月光为邻》" class="headerlink" title="《他与月光为邻》"></a>《他与月光为邻》</h2><blockquote><p>1.作者：丁墨<br>2.简介：他来自一个已经毁灭的文明，便如同时空中遗漏的细沙，曾经再多荣誉辉煌，终将在这个浩瀚的宇宙里，了无痕迹。如同从未存在过。<br>然而遇见了她才知道，半生戎马，铁血冤屈，人的渺小生命中再浓厚沉重的颜色，原来都比不过，她的床前，这一地温柔的月光。<br>第一次见面，她非要赠送给他一枚糕点。尽管他最讨厌甜食，还是努力吃掉了。<br>第二次，她因为害怕伸手抱了他。他脸色微红，“这位小姐，请先松手。”<br>第三次，她不小心亲了他，他一副见了鬼的表情，她却说：“意外而已，你不必介怀。”<br>作为一名接受过良好教育、身心健康的优秀军官，应寒时无法不介怀自己的初吻。<br>经过慎重考虑，他决定……对她负责。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近的状态：&lt;br&gt;不喜欢虐恋，不喜欢超长篇。&lt;br&gt;推的文章有最近看过，也有以前看过印象比较深刻的，每个系列倒序来更。&lt;/p&gt;
&lt;p&gt;实在太懒了，就随便写写。&lt;/p&gt;
&lt;h1 id=&quot;穿书文&quot;&gt;&lt;a href=&quot;#穿书文&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="推书" scheme="https://aoxiaodie.github.io/categories/%E6%8E%A8%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>太煽情不符合我高冷的气质。</title>
    <link href="https://aoxiaodie.github.io/2018/06/06/essay/nculiyan/"/>
    <id>https://aoxiaodie.github.io/2018/06/06/essay/nculiyan/</id>
    <published>2018-06-06T05:58:07.000Z</published>
    <updated>2019-02-27T08:28:01.726Z</updated>
    
    <content type="html"><![CDATA[<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"/assets/audio/nculiyan.webm"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p><br><br><br><br><img src="/assets/image/assay/aboutus.jpg" alt="our"><br>当我们都离开以后，<br>理研不复存在，<br>但是，<br>我们都会很好，<br>就像当初我们遇见的那样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;dplayer0&quot; class=&quot;dplayer hexo-tag-dplayer-mark&quot; style=&quot;margin-bottom: 20px;&quot;&gt;&lt;/div&gt;&lt;script&gt;(function(){var player = new DPlayer({&quot;c
      
    
    </summary>
    
      <category term="随笔" scheme="https://aoxiaodie.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Android</title>
    <link href="https://aoxiaodie.github.io/2018/05/24/language/Android/"/>
    <id>https://aoxiaodie.github.io/2018/05/24/language/Android/</id>
    <published>2018-05-24T14:30:47.000Z</published>
    <updated>2018-11-05T03:21:27.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p><strong>Activity负责与用户交互。</strong><br>View组件是所有UI组件、容器控件的基类，需要放在容器组件中，或用Activity将其显示。<br>调用<code>setContentView()</code>可以把指定的View显示处理。<br><code>setContentView()</code>可以接收一个View对象作为参数，也可以接受一个布局管理资源的ID作为参数。<br><br></p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><strong>Service通常用于为其他组件提供后台服务或监视其他组件的运行状态。</strong><br>Service与Activity地位相同，但通常位于后台运行，故此没有图形用户界面。<br>与Activity相似，Service组件需要继承Service基类。<br><br></p><h2 id="BroadcastRecevier"><a href="#BroadcastRecevier" class="headerlink" title="BroadcastRecevier"></a>BroadcastRecevier</h2><p>BroadcastRecevier代表广播消息接收器，类似于事件编程中的监听器，但监听的事件源是Android应用中的其他组件。<br><br></p><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider用于跨应用数据交换。<br><br></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="intent和intentFiltet"><a href="#intent和intentFiltet" class="headerlink" title="intent和intentFiltet"></a>intent和intentFiltet</h3><p>intent是不同组件之间通信的载体（Activity、Service、BroadcastRecevier）。</p><p>1.显式intent实现页面跳转<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><br><br>2.<br>在AndroiManifest.xml中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">  android:name=<span class="string">".FirstActivity"</span></span><br><span class="line">  android:label=<span class="string">"this is FirstActivity"</span></span><br><span class="line">  android:launchMode=<span class="string">"singleTask"</span>&gt;</span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span>&gt;</span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"com.example.activitytest.ACTION_START"</span>/&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p><p>在按钮点击事件中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>3.<code>putExtra()</code>向下一个活动传递数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String data = <span class="string">"Hello"</span>;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.putExtra(<span class="string">"Data"</span>,data);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>接收：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">String date = intent.getStringExtra(<span class="string">"Data"</span>);</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h2 id><a href="#" class="headerlink" title></a><br></h2><h1 id="界面编程"><a href="#界面编程" class="headerlink" title="界面编程"></a>界面编程</h1><h2 id="9Patch"><a href="#9Patch" class="headerlink" title="9Patch"></a>9Patch</h2><p>启动Android SDK/tools/draw9patch.bat即可制作。</p><h2 id="Toast显示提示信息框"><a href="#Toast显示提示信息框" class="headerlink" title="Toast显示提示信息框"></a>Toast显示提示信息框</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(context,<span class="string">"Text"</span>,Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure><p>1.用静态方法<code>makeText()</code>创建一个Toast对象；<br>2.三个参数，第一个是上下文Context，第二个是Toast要显示的文本内容，第三个是显示的时长，有LENGTH_SHORT和LENGTH_LONG两种；<br>3.调用<code>show()</code>显示。<br><br></p><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><p>显示提示消息的对话框<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">.setTitle(<span class="string">"简单对话框"</span>)</span><br><span class="line">.setIcon(R.drawble.tools)</span><br><span class="line">.setMessage(<span class="string">"测试内容"</span>);</span><br><span class="line">setPositiveButton(builder); <span class="comment">// 添加确定按钮</span></span><br><span class="line">setNegativeButton(builder) <span class="comment">// 添加取消按钮</span></span><br><span class="line">.create() <span class="comment">// 创建对象</span></span><br><span class="line">.show(); <span class="comment">// 显示</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><p>在res目录下新建一个menu文件夹（Directory），再其中新建一个main菜单文件。<br>1.在main.xml文件中创建两个菜单项：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">  android:id=<span class="string">"@id/add_item"</span></span><br><span class="line">  android:title=<span class="string">"Add"</span>/&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:id=<span class="string">"@id/remove_item"</span></span><br><span class="line">android:title=<span class="string">"Remove"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p><br><br>2.在主活动中重写方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionMenu</span><span class="params">(Menu menu)</span></span>&#123;</span><br><span class="line">  getMenuInflater().inflate(R.menu.main,menu);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>inflate()</code>方法接收两个参数，第一个用于指定资源文件，第二个用于指定菜单项将添加到那个Menu对象中。<br><br><br>3.重写方法定义菜单点击事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">    <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>,<span class="string">"you clicked add"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>,<span class="string">"you clicked remove"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h2 id="-1"><a href="#-1" class="headerlink" title></a><br></h2><h1 id="图形与图像处理"><a href="#图形与图像处理" class="headerlink" title="图形与图像处理"></a>图形与图像处理</h1><h2 id="Bitmap和Drawable"><a href="#Bitmap和Drawable" class="headerlink" title="Bitmap和Drawable"></a>Bitmap和Drawable</h2><p>Bitmap——位图，文件格式后缀为.bmp，可理解为一种存储对象。<br>Drawable——一种可以在Canvas上进行绘制的抽象的概念。<br><code>R.drawble.file_name</code>是一个int类型的常量，只代表Drawable对象的ID。</p><p>获取资源文件下的图片：<br><code>Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawble.file_name)</code></p><p>1.<code>createBitmap()</code>创建新的位图<br>2.<code>createScaledBitmap()</code>缩放位图<br><br></p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>重写<code>onDraw(Canvas canvas)</code>方法进行绘制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</span><br><span class="line">  Paint paint = <span class="keyword">new</span> Paint(); <span class="comment">// 定义并设置画笔</span></span><br><span class="line">  paint.setColor(Color.BLACK)</span><br><span class="line">  RectF rect = <span class="keyword">new</span> RectF(<span class="number">10</span>,<span class="number">10</span>,width-<span class="number">10</span>,height/<span class="number">3</span>-<span class="number">10</span>); <span class="comment">// 构建一个三角形，前两个参数是左上角坐标，后两个参数是右下角坐标</span></span><br><span class="line">  canvas.drawRect(rect,paint)</span><br><span class="line">  canvas.drawColor(Color.WHITE);</span><br><span class="line">  canvas.drawBitmap(bitmap,x,y,<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="双缓冲技术"><a href="#双缓冲技术" class="headerlink" title="双缓冲技术"></a>双缓冲技术</h2><p>原理：不直接绘制到View上，而是先绘制到内存中的一个Bitmap上，当内存图片绘制后，再一次性将Bitmap绘制到View组件上。<br><br></p><h2 id="AnimationDrawable逐帧动画"><a href="#AnimationDrawable逐帧动画" class="headerlink" title="AnimationDrawable逐帧动画"></a>AnimationDrawable逐帧动画</h2><p>1.（1）.在res/anim目录下创建动画文件anims.xml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;animation-list</span><br><span class="line">  xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">  android:oneshot=<span class="string">"false"</span> <span class="comment">// 循环播放</span></span><br><span class="line">  &lt;item android:drawable=<span class="string">"@mipmap/anim01"</span> android:duration=<span class="string">"80"</span> /&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p><br><br>（2）.设置动画到组件中：<br>布局管理<code>&lt;ImageView android:id=&quot;@id/animView&quot; android:src=&quot;@anim/anims&quot; /&gt;</code><br>调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imageView = (ImageView)findViewById(R.id.animView);</span><br><span class="line">AnimationDrawable anim = (AnimationDrawable)imageView.getDrawable();</span><br><span class="line">...</span><br><span class="line">anim.start(); <span class="comment">// 开始动画</span></span><br><span class="line">anim.stop(); <span class="comment">// 结束动画</span></span><br></pre></td></tr></table></figure></p><p><br><br>2.动态加载帧图片实现帧动画<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable anims = <span class="keyword">new</span> AnimationDrawable();</span><br><span class="line">TypedArray typedArray = getResources().obtainTypedArray(R.array.images);</span><br><span class="line"><span class="keyword">int</span>[] resourceImages = <span class="keyword">new</span> <span class="keyword">int</span>[typedArray.length()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; resourceImages.length;i++ ) &#123;</span><br><span class="line">  resourceImages = typedArray.getResourceId(i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">typedArray.recycle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; resourceImages.length;i++ ) &#123;</span><br><span class="line">  anims.addFrame(getResources().getDrawable(resourceImages[i],<span class="keyword">null</span>),speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imageView.getBackground(anims);</span><br></pre></td></tr></table></figure></p><p><br><br>补充：读取array.xml中的drawable数组资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypedArray typedArray = getResources().obtainTypedArray(R.array.images);</span><br><span class="line"><span class="keyword">int</span>[] resourceImages = <span class="keyword">new</span> <span class="keyword">int</span>[typedArray.length()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; resourceImages.length;i++ ) &#123;</span><br><span class="line">  resourceImages = typedArray.getResourceId(i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读取array.xml中的String数组资源<br><code>imageNames = getResources().getStringArray(R.array.Names)</code><br><br></p><h2 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h2><p>流程：</p><blockquote><p>1：创建一个Bitmap对象；<br>2：创建一个Canvas对象关联创建的Bitmap对象；<br>3：在Canvas上进行绘制；<br>4：锁定Canvas画布；<br>5：将Bitmap内容绘制到backBuffer中去；<br>6：解锁Canvas画布。</p></blockquote><p>1.创建自定义的SurfaceView，需要继承SurfaceView并实现SufaceHolder.Callback和Runnable两个接口：<br><code>public class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback,Runnable</code></p><p>对于SurfaceHolder.Callback方法，需要实现如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123; <span class="comment">//当创建时调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123; <span class="comment">//当改变时调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123; <span class="comment">//当销毁时调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于Runnable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>2.初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SurfaceHolder holder;</span><br><span class="line"><span class="keyword">private</span> Canvas canvas;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isDrawing; <span class="comment">// 控制绘画线程的标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MySurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(context, attrs);</span><br><span class="line">  holder = getHolder(); <span class="comment">// 获取SurfaceHolder对象</span></span><br><span class="line">  holder.addCallback(<span class="keyword">this</span>); <span class="comment">// 注册SurfaceHolder的回调方法</span></span><br><span class="line">  isDrawing = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>3.绘制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">  <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123; <span class="comment">// 锁定画布</span></span><br><span class="line">    canvas = holder.lockCanvas();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 绘制</span></span><br><span class="line">  <span class="keyword">if</span> (canvas != <span class="keyword">null</span>) &#123; <span class="comment">// 释放</span></span><br><span class="line">    holder.unlockCanvasAndPost(canvas);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h2 id="-2"><a href="#-2" class="headerlink" title></a><br></h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h2><p>1.继承Thread<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动：<code>new MyThrea().start()</code><br><br><br>2.实现Runnable接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread).start();</span><br></pre></td></tr></table></figure></p><p><br><br>3.匿名类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Handler消息传递机制"><a href="#Handler消息传递机制" class="headerlink" title="Handler消息传递机制"></a>Handler消息传递机制</h2><p>Android不允许子线程更新UI操作，所以使用Handler消息传递机制：</p><blockquote><p>Looper类：负责管理线程的消息队列和消息循环<br>Handler类：发送和处理消息<br>Message类：线程间通讯的消息载体</p></blockquote><p><br><br>1.普通线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerMessage</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.what == <span class="number">0x123</span>) &#123;</span><br><span class="line">      text.setText(message.obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.obj = <span class="string">"Hello"</span>;</span><br><span class="line">    message.what = <span class="number">0x123</span>;</span><br><span class="line">    handler.sendMessage(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p><p><br><br>2.循环线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  Looper.prepare();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    handler.sendEmptyMessage(<span class="number">0x123</span>); <span class="comment">// 发送空消息</span></span><br><span class="line">  &#125;</span><br><span class="line">  Looper.loop();</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p><h2 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h2><p>1.AsyncTast&lt;Params,Progress,Result&gt;<br>（1）Params：启动任务执行的输入参数的类型<br>（2）Progress：后台任务完成的进度值的类型<br>（3）Result：后台执行任务完成后返回结果的类型</p><p>2.必须在UI线程中创建AsyncTast的实例；<br>必须在UI线程调用AsyncTast的<code>execute()</code>方法。</p><p>一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTast</span> <span class="keyword">extends</span> <span class="title">AsyncTast</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>,<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span></span>&#123; <span class="comment">// 用于一些准备工作，如在界面显示进度条</span></span><br><span class="line">    <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Integer...params)</span></span>&#123; <span class="comment">// 后台线程将要完成的任务</span></span><br><span class="line">      publishProgress(Progress...values); <span class="comment">// 更新任务的执行进度</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer...values)</span></span>&#123; <span class="comment">// 更新进度，doInBackground()中的publishProgress()执行后触发</span></span><br><span class="line">    <span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span></span>&#123; <span class="comment">//后台任务执行成后显示的内容</span></span><br><span class="line">    <span class="keyword">super</span>.onPostExecute(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="创建一个服务："><a href="#创建一个服务：" class="headerlink" title="创建一个服务："></a>创建一个服务：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyService extends Service&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123; <span class="comment">// 创建时调用</span></span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent,<span class="keyword">int</span> flags,<span class="keyword">int</span> startId)</span></span>&#123; <span class="comment">// 启动时调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123; <span class="comment">// 销毁时调用</span></span><br><span class="line">    <span class="keyword">super</span>.onDestory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在AndroidManifest.xml中注册。<br><br></p><h3 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h3><p>启动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure></p><p>停止：<code>stopService(intent)</code></p><p>另外，在MyService的任何一个位置调用<code>stopSelf()</code>方法即可停止服务。<br><br></p><h3 id="活动和服务的通信"><a href="#活动和服务的通信" class="headerlink" title="活动和服务的通信"></a>活动和服务的通信</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServiceConnection conn = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bindService(intent,conn,BIND_AUTO_CREATE); <span class="comment">// 绑定服务</span></span><br><span class="line">unbindService(conn); <span class="comment">// 解绑服务</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="-3"><a href="#-3" class="headerlink" title></a><br></h2><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><h2 id="MediaPlayer播放音乐"><a href="#MediaPlayer播放音乐" class="headerlink" title="MediaPlayer播放音乐"></a>MediaPlayer播放音乐</h2><p>1.<code>MediaPlayer mediaPlayer</code><br>2.<code>mediaPlayer = MediaPlayer.create(this,R.raw.music)</code><br>3.<code>mediaPlayer.start()</code>、<code>mediaPlayer.stop()</code>、<code>mediaPlayer.pasue()</code><br>获取音频长度：<code>mediaPlayer.getDuration</code><br><br><br><br></p><h2 id="-4"><a href="#-4" class="headerlink" title></a><br></h2><h1 id="ListView和RecycleView"><a href="#ListView和RecycleView" class="headerlink" title="ListView和RecycleView"></a>ListView和RecycleView</h1><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>生成列表视图的方式：<br>（1）直接使用ListView创建；<br>（2）让Activity继承ListActivity。<br>获得ListView后，设置要显示的列表项，可以通过setAdapter()方法为其提供Adapter，并由Adapter提供列表项。</p><p>总得来说：<br>AdapterView是抽象基类；<br>ListView是容器，继承自AbsListView，负责显示列表项（AbsListView继承自AdapterView）；<br>Adapter是接口，几个常见的接口实现类：ArrayAdapter、SimpleAdapter、BaseAdapter等，也可以自定义。<br>Adapter提供每个列表项的组件。</p><p>1.list.xml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView android:id=<span class="string">"@+id/List"</span></span><br><span class="line">          android:layout_width=<span class="string">"match_parent"</span> android:layout_height=<span class="string">"0dp"</span> android:layout_weight=<span class="string">"1"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p><br><br>2.list_item.xml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView android:id=<span class="string">"@+id/Image"</span></span><br><span class="line">           android:layout_width=<span class="string">"100dp"</span> android:layout_height=<span class="string">"100dp"</span>/&gt;</span><br><span class="line">&lt;TextView android:id=<span class="string">"@+id/Text"</span> android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">          android:layout_width=<span class="string">"match_parent"</span> android:layout_height=<span class="string">"wrap_content"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p><br><br>3.List.java：略<br><br><br>4.ListAdapter.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListAdapter</span><span class="params">(Context context,<span class="keyword">int</span> textViewRecourceId,List&lt;List&gt; objects)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context,textViewResourceId,objects);</span><br><span class="line">        resourceId = textViewResourceId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position,View converView,ViewGroup parent)</span></span>&#123;</span><br><span class="line">    List list = getItem(position); <span class="comment">// 获取当前项的实例</span></span><br><span class="line">    View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,<span class="keyword">false</span>); <span class="comment">// LayoutInflater将子项传入布局</span></span><br><span class="line">    ImageView Image = (ImageView) view.findViewById(R.id.Image);</span><br><span class="line">    TextView Text = (TextView) view.findViewById(R.id.Text);</span><br><span class="line">    bkgImage.setImageResource(background.getImage());</span><br><span class="line">    bkgText.setText(background.getListText());</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>5.MainActivity.java或其它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&gt; list = <span class="keyword">new</span> ArrayAdapter&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savadInstanceState)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  initList();</span><br><span class="line">  ListAdapter adapter = <span class="keyword">new</span> ListAdapter(MainActivity.<span class="keyword">this</span>,R.layout.list_item,list);</span><br><span class="line">  ListView listview = (ListView)findViewById(R.id.List);</span><br><span class="line">  listview.setAdapter(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List list_item = <span class="keyword">new</span> List(<span class="string">"ex1"</span>,R.drawble.ex1);</span><br><span class="line">  list.add(list_item);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.ListView的点击事件：<br>在onCreate()方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">listview.setOnItemClickListener(<span class="keyword">new</span> AdapterView.OnItemClickListener()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnItemClick</span><span class="params">(AdapterView&lt;?&gt; parent,View view,<span class="keyword">int</span> position,<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">    List list_item = list.get(position);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h2><p>1.web.xml中添加依赖：<br><code>compile &#39;com.android.support:recycleView-v7:24.2.1&#39;</code><br><br><br>2.recycle.xml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">            android:id=<span class="string">"@+id/recycler_view"</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"0dp"</span> android:layout_weight=<span class="string">"1"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p><br><br>2.recycle_item.xml：略<br><br><br>3.Recycle.java：略<br><br><br>4.RecycleAdapter.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PortraitAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">PortraitAdapter</span>.<span class="title">ViewHolder</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Recycle&gt; mrecycle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        ImageView Image;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(view);</span><br><span class="line">            Image = (ImageView) view.findViewById(R.id.Image);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PortraitAdapter</span><span class="params">(List&lt;Portrait&gt; recycle)</span></span>&#123;</span><br><span class="line">        mrecycle = recycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span>&#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycle_item,parent,<span class="keyword">false</span>);</span><br><span class="line">        ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder,<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        Recycle recycle = mrecycle.get(position);</span><br><span class="line">        holder.tImage.setImageResource(portrait.getImage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPortrait.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>5.MainActivity.java或其它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Recycle&gt; recycleList = <span class="keyword">new</span> ArrayAdapter&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  initRecycle();</span><br><span class="line">  RecycleView recycleView = (RecycleView)findViewById(R.id.recycler_view);</span><br><span class="line">  LinearLayoutManger layoutManage = <span class="keyword">new</span> LinearLayoutManger(<span class="keyword">this</span>); <span class="comment">// 线性排列</span></span><br><span class="line">  recycleView.setLayoutManager(layoutManage);</span><br><span class="line">  RecycleAdapter adapter = <span class="keyword">new</span> RecycleAdapter(recycleList);</span><br><span class="line">  recycleView.setAdapter(adapter);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p><br><br>6.RecycleView的点击事件：</p><p><br><br><br></p><h2 id="-5"><a href="#-5" class="headerlink" title></a><br></h2><h1 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>1.标准广播：完全异步执行的广播，发送后所有的广播接收器几乎都会在同一时刻接收到。<br>2.有序广播：同步执行的广播。<br><br></p><h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><h3 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="动态注册监听网络变化"></a>动态注册监听网络变化</h3><p>创建广播接收器：新建一个类，继承BroadcastReciver，并重写父类的<code>onReciver()</code>方法即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> IntentFilter intentFilter;</span><br><span class="line">  <span class="keyword">private</span> NetworkChangeReceiver networkChangeReceiver;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 广播接收器想要监听什么广播，就在这里添加相应的action</span></span><br><span class="line">    intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</span><br><span class="line">    networkChangeReceiver = <span class="keyword">new</span> NetworkChangeReceiver();</span><br><span class="line">    registerRecevier(networkChangeReceiver,intentFilter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123; <span class="comment">// 动态注册的广播接收器一定要取消注册</span></span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    unregisterRecevier(networkChangeReceiver);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReciver</span><span class="params">(Context context,Intent intent)</span></span>&#123;</span><br><span class="line">      Toast.makeText(context,<span class="string">"network change"</span>,Toast.LENGHT_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="静态注册实现开机启动"><a href="#静态注册实现开机启动" class="headerlink" title="静态注册实现开机启动"></a>静态注册实现开机启动</h3><p>实现在程序未启动的情况下接收广播。<br>静态广播接收器一定要在AndroidManifest.xml文件中注册才可以使用。</p><p>由于系统启动完成后会发出一条值为<code>android.intent.action.BOOT_COMPLETED</code>的广播，所以要添加相应的action：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">  .../&gt;</span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"android.intent.action.BOOT_COMPLETED"</span>&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><p>即让广播接收器监听这条广播。<br><br></p><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>创建一个自定义广播，修改AndroidManifest.xml：<br><code>&lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;&gt;</code><br>即可接收消息。</p><h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><p>修改：<code>sendOrderBroadcast(intent,null)</code></p><p>可以设置广播接收器的优先级：<br><code>&lt;intent-filter android:priority=&quot;100&quot;&gt;</code><br><br><br><br></p><h2 id="-6"><a href="#-6" class="headerlink" title></a><br></h2><h1 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h1><h2 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h2><p>1.<br>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK = <span class="string">"create table Bool("</span>+<span class="string">" id integer primary key autoincrement,"</span>+<span class="string">" author text)"</span>;</span><br><span class="line">  <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一个参数——上下文，第二个参数——数据库名，第三个参数——一般为null，第四个参数——当前数据库版本号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDatabaseHelper</span><span class="params">(Context context,String name,SQLiteDatabase.CursorFactory factory,<span class="keyword">int</span> version)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context,name,factory,version);</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">    db.execSQL(CREATE_BOOK);</span><br><span class="line">    Toast.makeText(context,<span class="string">"Create succeeded"</span>,Toast.LENGHT_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,<span class="keyword">int</span> oldVersion,<span class="keyword">int</span> newVersion)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用于升级数据库</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建SQLiteOpenHelper实例，调用其实例方法<code>getReadableDatabase()</code>或<code>getWriteDatabase()</code>来创建或打开一个现有的数据库。<br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyDatabaseHelper dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line">dbHelper.getWriteDatabase();</span><br></pre></td></tr></table></figure></p><p><br><br>2.插入一个新的表<br>修改<code>onCreate()</code>方法，多加一条：<code>db.execSQL(CREATE_CATEGORY)</code><br>修改<code>onUpgrade()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,<span class="keyword">int</span> oldVersion,<span class="keyword">int</span> newVersion)</span></span>&#123;</span><br><span class="line">  db.execSQL(<span class="string">"drop table if exits Book"</span>);</span><br><span class="line">  db.execSQL(<span class="string">"drop table if exits Category"</span>);</span><br><span class="line">  onCreate(db);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>1.增删改<br>方法<code>getReadableDatabase()</code>或<code>getWriteDatabase()</code>会返回一个SQLiteDatabase对象，借助该对象可以实现对数据的增删查改。<br>主活动中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = dbHelper.getWriteDatabase();</span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"id"</span>,<span class="number">001</span>);</span><br><span class="line">values.put(<span class="string">"author"</span>,<span class="string">"xusong"</span>);</span><br><span class="line">db.insert(<span class="string">"Book"</span>,<span class="keyword">null</span>,values);</span><br><span class="line">db.update(<span class="string">"Book"</span>,values,<span class="string">"id = 001"</span>);</span><br><span class="line">db.delete(<span class="string">"Book"</span>,values,<span class="string">"id = 001"</span>);</span><br></pre></td></tr></table></figure></p><p><br><br>2.查<br><code>Cursor cursor = db.query(&quot;Book&quot;,null,null,null,null,null,null)</code><br><code>cursor.moveToFirst()</code>指针移动到第一个，<code>cursor.moveToNext()</code>指针后移。</p><p>//</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;四大组件&quot;&gt;&lt;a href=&quot;#四大组件&quot; class=&quot;headerlink&quot; title=&quot;四大组件&quot;&gt;&lt;/a&gt;四大组件&lt;/h1&gt;&lt;h2 id=&quot;Activity&quot;&gt;&lt;a href=&quot;#Activity&quot; class=&quot;headerlink&quot; title=&quot;A
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://aoxiaodie.github.io/2018/05/07/Base/Data-structure/"/>
    <id>https://aoxiaodie.github.io/2018/05/07/Base/Data-structure/</id>
    <published>2018-05-07T07:30:02.000Z</published>
    <updated>2018-05-07T08:45:57.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p>1.数据：所有能够输入到计算机中并被计算机程序处理的符号的总称；<br>2.数据元素：数据的基本单位；<br>3.数据项：数据的不可分割的最小单位；<br>4.数据对象：数据的一个子集；<br>5.数据结构：相互之间存在一种或多种特定关系的数据元素的集合；<br>6.抽象数据类型（ADT）：一个数学模型以及定义在该模型上的一组操作。</p><p><img src alt="Data Structure"><br><br><br><br><br><br></p><hr><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>用一组地址连续的存储单元依次存储线性表的数据元素。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType* elem; <span class="comment">// 存储空间基址</span></span><br><span class="line">  <span class="keyword">int</span> length; <span class="comment">// 当前长度</span></span><br><span class="line">  <span class="keyword">int</span> listsize; <span class="comment">// 初始存储容量</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;基本概念和术语&quot;&gt;&lt;a href=&quot;#基本概念和术语&quot; class=&quot;headerlink&quot; title=&quot;基本概念和术语&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://aoxiaodie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>cocos2d-x入门</title>
    <link href="https://aoxiaodie.github.io/2018/04/09/games-development/cocos/"/>
    <id>https://aoxiaodie.github.io/2018/04/09/games-development/cocos/</id>
    <published>2018-04-09T08:45:46.000Z</published>
    <updated>2019-02-27T08:36:46.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="解决方案目录结构"><a href="#解决方案目录结构" class="headerlink" title="解决方案目录结构"></a>解决方案目录结构</h2><p>1.resource文件夹<br>主要用于存放游戏中需要的图片、音频和配置等资源文件。</p><p>2.src文件夹（Classes）<br>存放AppDelegate文件、GameScene（场景类）文件、GameSprite（精灵类）文件以及GameLayer（层）文件。</p><p>3.win32文件夹<br>main函数。<br><br></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="导演（Director）"><a href="#导演（Director）" class="headerlink" title="导演（Director）"></a>导演（Director）</h2><p>主要作用：</p><blockquote><p>（1）环境设定（初始化OpenGL和渲染器）<br>（2）场景管理<br>（3）执行主循环<br>游戏就是个死循环，不断地渲染，再一帧一帧的绘制出来。</p></blockquote><p><br></p><h2 id="场景（Scene）"><a href="#场景（Scene）" class="headerlink" title="场景（Scene）"></a>场景（Scene）</h2><p>游戏里关卡、版块的切换就是场景的切换。<br>其一个重要作用是流程控制。<br>可以用Director控制场景：<br><img src="/assets/image/data/cocos/Director_Scene.PNG" alt="Director_Scene"></p><h3 id="场景图"><a href="#场景图" class="headerlink" title="场景图"></a>场景图</h3><p>是一种安排场景内对象的数据结构，它把场景内所有的节点(Node)都包含在一个 树(tree)上。<br>虽然称为“图”，但实际是用一个树结构来表示。<br>每个元素就是一个节点，通过z-order来设置节点的位置，z-order为负的被放置在左子树，非负的即在右子树。cocos2d-x使用 <strong>中序遍历</strong> ，先遍历左子树，然后根节点，最后右子树。<br><br><br>构建场景图：<code>Scene</code>的<code>addChild()</code>方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scene-&gt;addChild(title_node,<span class="number">-2</span>)</span><br><span class="line">scene-&gt;addChild(lable_node)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h3><p>1.<code>runWithScene()</code>用于开始游戏，加载第一个场景。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myScene = Scene::create();</span><br><span class="line">Director::getInstance()-&gt;runWithScene(myScene);</span><br></pre></td></tr></table></figure></p><p>2.<code>replaceScene()</code>使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</p><p>3.<code>pushScene()</code>将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。</p><p>4.<code>popScene()</code>释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。<br><br></p><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>Node类是绝大部分类的父类。<br><img src="/assets/image/data/cocos/class.PNG" alt="Classes"><br><br></p><h2 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a>层（Layer）</h2><p>层包含的是直接在屏幕上呈现的内容，并且可以接受用户的输入事件，包括触摸、键盘输入等。我们需要在层中加入精灵，文本标签或者其他游戏元素，并设置游戏元素的属性，比如位置，方向和大小；设置游戏元素的动作等。<br><br></p><h2 id="精灵（Sprite）"><a href="#精灵（Sprite）" class="headerlink" title="精灵（Sprite）"></a>精灵（Sprite）</h2><p>能够被控制的对象才是精灵，无法控制的对象就只是一个节点（Node）。<br><br><br>锚点（anchor point）<br>所有的节点对象都有锚点。<br>锚点是节点对象在计算坐标位置时的一个基准点。<br><br></p><h4 id="创建一个精灵："><a href="#创建一个精灵：" class="headerlink" title="创建一个精灵："></a>创建一个精灵：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::create(<span class="string">"mysprite.png"</span>);</span><br><span class="line"><span class="comment">// 一些属性</span></span><br><span class="line">mySprite-&gt;setPosition(Vec2(<span class="number">500</span>, <span class="number">0</span>)); <span class="comment">// 位置</span></span><br><span class="line">mySprite-&gt;setRotation(<span class="number">40</span>); <span class="comment">// 旋转角度</span></span><br><span class="line">mySprite-&gt;setScale(<span class="number">2.0</span>); <span class="comment">// 缩放比例</span></span><br><span class="line">mySprite-&gt;setAnchorPoint(Vec2(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 锚点</span></span><br><span class="line">mySprite-&gt;setColor(Color3B::WHITE); <span class="comment">// 颜色</span></span><br><span class="line">mySprite-&gt;setColor(Color3B(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">mySprite-&gt;setOpacity(<span class="number">30</span>); <span class="comment">// 透明度</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image/data/cocos/relation.PNG" alt="relation"><br><br></p><h4 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h4><p>图集（Sprite Sheet）是通过专门的工具将多张图片合成一张大图，并通过plist等格式的文件索引资源。<br>使用图集比使用多个独立图像占用的磁盘空间更少，且有更好的性能。</p><p><code>SpriteFrameCache</code>是一个全局的缓存类，在使用图集时，首先将全部资源加载到<code>SpriteFrameCache</code>中，缓存了添加的<code>SpriteFrame</code>对象，<code>SpriteFrame</code>只加载一次，后续一直保存在<code>SpriteFrameCache</code>中。</p><p>加载图集的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spritecache = SpriteFrameCache::getInstance();</span><br><span class="line">spritecache-&gt;addSpriteFramesWithFile(<span class="string">"sprites.plist"</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="精灵缓存"><a href="#精灵缓存" class="headerlink" title="精灵缓存"></a>精灵缓存</h4><p>把精灵放入精灵缓存对象中，提高精灵的访问速度：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mysprite = Sprite::createWithSpriteFrameName(<span class="string">"mysprite.png"</span>);</span><br></pre></td></tr></table></figure></p><p><br><br>还可以从精灵缓存对象<code>SpriteFrameCache</code>中访问一个精灵：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newspriteFrame = SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName(<span class="string">"Blue_Front1.png"</span>); <span class="comment">// 获取</span></span><br><span class="line"><span class="keyword">auto</span> newSprite = Sprite::createWithSpriteFrame(newspriteFrame); <span class="comment">//创建</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="动作（Action）"><a href="#动作（Action）" class="headerlink" title="动作（Action）"></a>动作（Action）</h2><p>动作可以让精灵在场景中移动，如从一个点移动到另外一个点。</p><p>Action对象的创建：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::create(<span class="string">"Blue_Front1.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::create(<span class="number">2</span>, Vec2(<span class="number">50</span>,<span class="number">10</span>));</span><br><span class="line">mySprite-&gt;runAction(moveBy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::create(<span class="number">2</span>, Vec2(<span class="number">50</span>,<span class="number">10</span>));</span><br><span class="line">mySprite-&gt;runAction(moveTo);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="By和To的区别"><a href="#By和To的区别" class="headerlink" title="By和To的区别"></a>By和To的区别</h3><p>如果想让动作的表现相对于Node当前位置的，就用By；<br>如果想让动作的表现是按照坐标的绝对位置的，就用To。<br><br></p><h3 id="基本动作"><a href="#基本动作" class="headerlink" title="基本动作"></a>基本动作</h3><p>1.移动<br>使用<code>MoveTo</code>  <code>MoveBy</code>完成节点对象在一个设置的时间后移动。</p><p>2.旋转<br><code>RotateTo</code> <code>RotateBy</code></p><p>3.缩放<br><code>ScaleTo</code> <code>ScaleBy</code></p><p>4.淡入淡出<br><code>FadeIn</code>从完全透明到完全不透明，<code>FadeOut</code>则相反。</p><p>5.色彩混合<br><code>TintTo</code> <code>TintBy</code><br><br></p><h3 id="动作序列（Sequence）"><a href="#动作序列（Sequence）" class="headerlink" title="动作序列（Sequence）"></a>动作序列（Sequence）</h3><p>可以通过创建一个动作序列(Sequence)，让精灵按照这个序列做连续的动作。</p><p>动作序列(Sequence) 是一种封装多个动作的对象，当这个对象执行时被封装的动作会顺序执行。</p><h4 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h4><p>Spawn可以同时执行多个动作，效果和同时运行多个动作的<code>runAction()</code>方法相同。<br>如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::create(<span class="string">"mysprite.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::create(<span class="number">10</span>, Vec2(<span class="number">400</span>,<span class="number">100</span>));</span><br><span class="line"><span class="keyword">auto</span> fadeTo = FadeTo::create(<span class="number">2.0f</span>, <span class="number">120.0f</span>);</span><br></pre></td></tr></table></figure></p><p>使用Spawn：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySpawn = Spawn::createWithTwoActions(moveBy, fadeTo);</span><br><span class="line">mySprite-&gt;runAction(mySpawn);</span><br></pre></td></tr></table></figure></p><p>或者同时调用<code>runAction()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySprite-&gt;runAction(moveBy);</span><br><span class="line">mySprite-&gt;runAction(fadeTo);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="动作的克隆"><a href="#动作的克隆" class="headerlink" title="动作的克隆"></a>动作的克隆</h3><p><code>clone()</code><br><br></p><h3 id="动作的倒转"><a href="#动作的倒转" class="headerlink" title="动作的倒转"></a>动作的倒转</h3><p><code>reverse()</code><br><br><br><br><br><br></p><hr><h1 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h1><p><img src="/assets/image/data/cocos/classes.PNG" alt="classes"><br><br><br><br><br><br></p><hr><h1 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;h2 id=&quot;解决方案目录结构&quot;&gt;&lt;a href=&quot;#解决方案目录结构&quot; class=&quot;headerlink&quot; title=&quot;解决方案目录结构&quot;
      
    
    </summary>
    
      <category term="游戏开发" scheme="https://aoxiaodie.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin</title>
    <link href="https://aoxiaodie.github.io/2018/03/21/language/kotlin/"/>
    <id>https://aoxiaodie.github.io/2018/03/21/language/kotlin/</id>
    <published>2018-03-21T05:53:22.000Z</published>
    <updated>2018-08-19T09:12:08.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="最简版"><a href="#最简版" class="headerlink" title="最简版"></a>最简版</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Hello,<span class="variable">$name</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  Greeter(args[<span class="number">0</span>]).greet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><hr><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>使用<code>fun</code>关键字定义函数，参数格式为 <strong>参数:类型</strong>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123; <span class="comment">//返回Int</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者将表达式作为函数体，返回类型自动推断：<code>fun sum(a:Int,b:Int) = a + b</code></p><p><strong>注意：public方法则必须明确写出返回类型</strong><br><code>public fun sum(a:Int,b:Int):Int = a + b</code></p><p>1.无返回值的函数<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Unit</span>&#123;</span><br><span class="line">  print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是返回Unit类型，可以直接省略：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">  print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>2.可变参数函数<br>用<code>vararg</code>关键字标识<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> num:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(vt <span class="keyword">in</span> num)&#123;</span><br><span class="line">    print(vt)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为</p><blockquote><p>12345</p></blockquote><p>3.lambda（匿名函数）<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> sumLambda: (<span class="built_in">Int</span>,<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x,y -&gt; x + y&#125;</span><br><span class="line">  printn(sumLambda(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为3<br><br><br><br><br><br></p><hr><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p>1.可变变量定义：var关键字</p><blockquote><p>var &lt;标识符&gt;:&lt;类型&gt;=&lt;初始化值&gt;</p></blockquote><p><br><br>2.不可变变量定义：val关键字</p><blockquote><p>val &lt;标识符&gt;:&lt;类型&gt;=&lt;初始化值&gt;</p></blockquote><p><br><br><br><br><br></p><hr><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h2><p>“===”表示比较对象地址，“==”表示比较两个值的大小。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">Strig</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> a : <span class="built_in">Int</span> = <span class="number">1000</span></span><br><span class="line">  println(a === a)<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>其他数据类型同理。<br><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的创建有两种方式：一种是使用函数arrayOf()；另一种是使用工厂函数。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> a = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br><span class="line">  <span class="keyword">val</span> b = Array(<span class="number">3</span>,&#123;i -&gt; (i * <span class="number">2</span>)&#125;) <span class="comment">// [0,2,4]</span></span><br><span class="line"></span><br><span class="line">  println(a[<span class="number">0</span>]) <span class="comment">// 输出结果为1</span></span><br><span class="line">  println(b[<span class="number">1</span>]) <span class="comment">// 输出结果为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组：<code>val x: IntArray = intArrayOf(1, 2, 3)</code><br><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>1.可以通过[]语法获取字符串中的某个字符，也可以通过for循环来遍历：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str)&#123;</span><br><span class="line">  println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>2.Kotlin支持多行字符串：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">  多行字符串</span></span><br><span class="line"><span class="string">  多行字符串</span></span><br><span class="line"><span class="string">  ..</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  println(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.String 可以通过<code>trimMargin()</code>方法来删除多余的空白<br><br><br><br><br><br></p><hr><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><h2 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h2><p>与其他语言相似，但可以作为表达式<code>val max = if (a &gt; b) a else b</code><br><br></p><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> x = <span class="number">5</span></span><br><span class="line">  <span class="keyword">val</span> y = <span class="number">9</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">8</span>)&#123;</span><br><span class="line">    println(<span class="string">"x 在区间内"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h2><p>when类似于其他语言的switch操作符，将其参数和所有分支条件顺序比较，直到某个分支满足条件，其中，else同switch里的default。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x)&#123;</span><br><span class="line">  <span class="number">1</span> -&gt; println(<span class="string">"x == 1"</span>)</span><br><span class="line">  <span class="number">2</span> -&gt; println(<span class="string">"x == 2"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">    println(<span class="string">"x不是1，也不是2"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>when也可以用来取代if-else-if链，当一个分支的条件为真时则执行该分支。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><hr><h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> items = listOf(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"kiwi"</span>)</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> items)&#123;</span><br><span class="line">    println(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index <span class="keyword">in</span> items.indices)&#123;</span><br><span class="line">    println(<span class="string">"item at <span class="variable">$index</span> is <span class="subst">$&#123;items[index]&#125;</span>"</span>) <span class="comment">// $有些类似C里的取地址符&amp;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>apple<br>banana<br>kiwi<br>item at 0 is apple<br>item at 1 is banana<br>item at 2 is kiwi</p></blockquote><p><br></p><h2 id="while和do…while循环"><a href="#while和do…while循环" class="headerlink" title="while和do…while循环"></a>while和do…while循环</h2><p>与Java相似。<br><br></p><h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>return：返回<br>break：终止它所在的循环<br>continue：跳出该循环继续下一次循环<br><br><br><br><br><br></p><hr><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>1.类属性修饰符</p><blockquote><p>abstract // 抽象类<br>final // 最终类，不可继承，默认属性<br>enum // 枚举类<br>open // 可继承类<br>annotation //注解类</p></blockquote><p><br><br>2.访问权限修饰符</p><blockquote><p>private // 仅在同一个文件中可见<br>protected // 同一个文件中或子类可见<br>public // 所有调用的地方都可见<br>internal // 同一个模块中可见</p></blockquote><p><br></p><h2 id="类的定义，与Java相似。"><a href="#类的定义，与Java相似。" class="headerlink" title="类的定义，与Java相似。"></a>类的定义，与Java相似。</h2><p>如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runoob</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: String = ...</span><br><span class="line">  <span class="keyword">var</span> url: String = ...</span><br><span class="line">  <span class="keyword">var</span> city: String = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以定义空类：<code>class Empty</code>。<br><br></p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>使用构造函数创建类的实例：<code>val site = Runoob()</code>。<br><strong>注意：没有new关键字。</strong><br><br></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>用名称加“ . ”来引用即可：<code>site.name</code>。<br><br></p><h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><blockquote><p>var 属性名: 类型 = 初始化值<br>  <getter><br>  <setter></setter></getter></p></blockquote><h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><p>setter和getter都是可选的，val不允许设置setter函数<br>一些例子：</p><blockquote><p>var a: Int? // 错误，需要一个初始化语句，默认实现getter和setter方法<br>var b = 1 // 默认实现getter和setter方法<br>var c: Int? // 默认实现getter，但必须在构造函数中初始化<br>val d = 1 // 默认实现getter</p></blockquote><p><br></p><h3 id="非空属性"><a href="#非空属性" class="headerlink" title="非空属性"></a>非空属性</h3><p>非空属性必须在定义时初始化，但可用<code>lateinit</code>关键字描述，如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="主构造器和次构造器"><a href="#主构造器和次构造器" class="headerlink" title="主构造器和次构造器"></a>主构造器和次构造器</h3><p>Kotlin中的类可以有一个主构造器，以及一个或多个次构造器</p><p>1.主构造器是类头部的一部分，位于类名称之后，主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">         println(<span class="string">"FirstName is <span class="variable">$firstName</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以通过主构造器来定义属性并初始化属性值：<code>class People(val firstName: String, val lastName: String){}</code></p><p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。<br><br><br>2.次级构造函数需要加前缀<code>constructor</code><br>如果类有主构造函数，每个次构造函数都要用<code>this</code>关键字直接或间接通过另一个次构造函数代理主构造函数。</p><p>直接看一个实例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">constructor</span></span>(name: String)&#123;</span><br><span class="line">  <span class="keyword">var</span> Name = name</span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    println(<span class="string">"初始化名称：<span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (name: String,alexa: <span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">    println(<span class="string">"Alexa 排名 <span class="variable">$alexa</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">printTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"我是函数"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> test = Test(<span class="string">"测试"</span>,<span class="number">100</span>)</span><br><span class="line">  println(test.name)</span><br><span class="line">  println.printTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为</p><blockquote><p>初始化名称：测试<br>Alexa 排名 100<br>测试<br>我是函数</p></blockquote><p><br></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><br></p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> demo = Outer.Nested().foo()</span><br><span class="line">  println(demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为2<br><br></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><br><br><br><br><br></p><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>Kotlin所有类都继承自Any类，它是所有类的超类。<br>Any默认提供了三个函数：</p><blockquote><p>equals()<br>hashCode()<br>ToString()</p></blockquote><p>如果一个类要被继承，可以使用<code>open</code>关键字进行修饰，因为默认是final类。<br><br><br><br><br><br></p><hr><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>与Java相似：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"foo"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>: <span class="type">MyInterface&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"bar"</span>)</span><br><span class="line">    &#125; <span class="comment">// 重写实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> c = Child()</span><br><span class="line">  c.foo()</span><br><span class="line">  c.bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><hr><h1 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h1><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改</p><blockquote><p>fun 原类.扩展函数名(扩展函数参数，可为null)</p></blockquote><p>实例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> name: String)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> User.<span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"用户名 <span class="variable">$name</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = User(<span class="string">"测试"</span>)</span><br><span class="line">  user.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：测试<br><br><br><br><br><br></p><hr><h1 id="Kotlin中的null安全"><a href="#Kotlin中的null安全" class="headerlink" title="Kotlin中的null安全"></a>Kotlin中的null安全</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Forecast forecast = <span class="literal">null</span></span><br><span class="line">forecast.ToString()</span><br></pre></td></tr></table></figure><p>这段代码可以被编译执行，但会抛出<code>NullPointerException</code>错误。<br><br><br>1.指定一个变量是可null<br>在类型最后添加一个问号：<code>val a: Int? = null</code></p><p>一个可null类型，没有进行检查之前不能直接使用，如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">a.toString()</span><br></pre></td></tr></table></figure></p><p>不能被编译。<br><br><br>2.安全调用<br><code>?.</code>操作符<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">a?.toString()</span><br></pre></td></tr></table></figure></p><p><code>a?.toString()</code>表示如果a不是null，这个表达式将会被执行，否则返回null。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;h2 id=&quot;最简版&quot;&gt;&lt;a href=&quot;#最简版&quot; class=&quot;he
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>unity入门</title>
    <link href="https://aoxiaodie.github.io/2018/03/19/games-development/unity/"/>
    <id>https://aoxiaodie.github.io/2018/03/19/games-development/unity/</id>
    <published>2018-03-19T05:58:35.000Z</published>
    <updated>2018-08-19T09:20:27.910Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="游戏开发" scheme="https://aoxiaodie.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>C# 入门</title>
    <link href="https://aoxiaodie.github.io/2018/02/06/language/C#/"/>
    <id>https://aoxiaodie.github.io/2018/02/06/language/C#/</id>
    <published>2018-02-06T06:18:30.000Z</published>
    <updated>2018-08-19T09:12:10.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="Hello-World实例"><a href="#Hello-World实例" class="headerlink" title="Hello World实例"></a>Hello World实例</h2><p>一个C#程序主要包括：命名空间声明、一个class、class方法、class属性、Main方法、语句和表达式、注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace HelloWorldApplication&#123;// 一个 namespace 是一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。</span><br><span class="line">  clss HelloWord&#123;// 一个类</span><br><span class="line">    static void Main(string[] args)&#123;// 主方法</span><br><span class="line">      Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">      Console.ReadKey();// 最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><strong>注意点：</strong><br>1、大小写敏感；<br>2、与Java不同，文件名可以不同于类名。<br><br><br><br><br><br></p><hr><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using System</span><br><span class="line">namespace RectangleApplication&#123;</span><br><span class="line">  class Rectangle&#123;</span><br><span class="line">    double length;</span><br><span class="line">    double width;</span><br><span class="line">    public void Acceptdetails()&#123;</span><br><span class="line">      length = 4.5;</span><br><span class="line">      width = 3.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double GetArea()&#123;</span><br><span class="line">      return length * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Display()&#123;</span><br><span class="line">      Console.WriteLine(&quot;Length: &#123;0&#125;&quot;,length);</span><br><span class="line">      Console.WriteLine(&quot;Width: &#123;0&#125;&quot;,width);</span><br><span class="line">      Console.WriteLine(&quot;Area: &#123;0&#125;&quot;,GetArea());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class ExecuteRectangle&#123;</span><br><span class="line">    static void Main(String[] args)&#123;</span><br><span class="line">      Rectangle r = new Rectangle();</span><br><span class="line">      r.Acceptdetails();</span><br><span class="line">      r.Display();</span><br><span class="line">      Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>基本语法</p><blockquote><p>命名空间.命名空间…命名空间.类名.静态方法名(参数,…) ;</p></blockquote><p>如<code>System.Console.WriteLine(&quot;Hello World&quot;)</code><br><br></p><h2 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h2><p>三个用途：<br>（1）作为引用指令，用于为命名空间导入其他命名空间中定义的类型。<br>如在程序开头加上<code>using System</code>，则<code>System.Console.WriteLine(&quot;Hello World&quot;)</code>可以直接写成<code>Console.WriteLine(&quot;Hello World&quot;)</code>。<br><br><br>（2）作为别称指令，用于简化命名空间的表达形式。<br>如<code>using WinForm=System.Windows.Form</code><br>这样一来，<code>System.Windows.Form.MessageBox.Show(&quot;hello&quot;)</code>可以简化为<code>WinForm.MessageBox.Show(&quot;hello&quot;)</code>。<br><br><br>（3）作为一个语句，用于定义一个范围。<br>using关键字可以用来创建using语句，该语句的作用是定义一个用大括号包围的范围，程序执行到此范围的末尾，会立即释放在using小括号内创建的对象。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main()&#123;</span><br><span class="line">  using (TextWriter w = File.CreateText(&quot;test.txt&quot;))&#123;</span><br><span class="line">    w.WriteLine(&quot;Line one&quot;);</span><br><span class="line">    w.WriteLine(&quot;Line two&quot;);</span><br><span class="line">    w.WriteLine(&quot;Line three&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。<br><br></p><h2 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h2><p>Main方法只有两种类型的返回值，即只能声明为<code>public static int Main()</code>或者<code>public static void Main()</code>。<br><br></p><h2 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h2><p>声明一个类。<br><br></p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>类的命名必须遵循如下基本规则：<br>1、标识符由字母、数字、下划线和@组成，必须以字母、下划线或@开头；<br>2、不能是 C# 关键字；<br>3、区分大小写；<br>4、不能与 C# 类库名称相同。<br><br></p><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C# 关键字"></a>C# 关键字</h2><p>1、保留关键字；<br>2、上下文关键字。<br><br><br><br><br><br></p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>从类System.ValueType中派生。<br>值类型直接包含数据。<br><br><br>如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 sizeof 方法。表达式 sizeof(type) 产生以字节为单位存储对象或类型的存储尺寸。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace DataTypeApplication&#123;</span><br><span class="line">  class Program&#123;</span><br><span class="line">    static void Main(String[] args)&#123;</span><br><span class="line">      Console.WriteLine(&quot;Size of int: &#123;0&#125;&quot;,sizeof(int));</span><br><span class="line">      Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为</p><blockquote><p>Size of int:4</p></blockquote><p><br></p><p>##引用类型<br>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用，即该变量的位置。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p>1、对象类型是 C# 通用类型系统（Common Type System - CTS)中所有数据类型的终极基类。<br>2、Object是System.Object类的别名。<br>3、对象类型可以分配任何其他类型的值，但在分配值前需要先进行类型转换。<br>4、当一个值类型转换成对象类型时，则为装箱；一个对象类型转换成值类型时，则为拆箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">obj = 100;// 装箱</span><br></pre></td></tr></table></figure><p><br></p><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic &lt;variable_name&gt; = value;</span><br></pre></td></tr></table></figure></p><p>动态类型与对象类型相似，但对象类型变量的类型检查是在编译时发生，而动态类型则在运行时发生。<br><br></p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>1、字符串类型是System.String类的别名；<br>2、从对象Objcet类派生；<br>3、可以通过两种形式进行分配：引号和@引号。</p><p>如：<code>String str = &quot;HelloWord&quot;</code><br>一个@引号字符串:<code>String str = @&quot;HelloWord&quot;</code></p><p>在 C# 字符串的前面加@（逐字字符串）将转义字符转换成普通字符：<br><code>String str = @&quot;C:\Windows&quot;</code><br>等价于：<code>String str = &quot;C:\\Windows&quot;</code></p><p>@字符串中可以任意换行，换行符及缩进空格都计算在字符串的长度之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = @&quot;&lt;script type = &quot;&quot;text/javascript&quot;&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/script&gt;&quot;;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>C# 中的指针与 C 或 C++ 中的指针有相同的功能。<br>声明指针类型：<code>type* identifier</code><br><br><br><br><br><br></p><hr><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型转换从根本上说是类型铸造。<br>分两种：<br>1、隐式类型转换：如从低精度类型转换成高精度类型、从派生类转换成基类等；<br>2、显式类型转换：即强制类型转换，和C/C++差不多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">namespace TypeConvertion&#123;   </span><br><span class="line">  class Class1&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Class2 : Class1 //类Class2是类Class1的子类&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Program&#123;</span><br><span class="line">    static void Main(string[] args)&#123;</span><br><span class="line">      int inum = 100;</span><br><span class="line">      long lnum = inum; // 进行了隐式转换</span><br><span class="line">      Class1 c1 = new Class2(); // 隐式转换，将一个新建的 Class2 实例转换为了其基类 Class1 类型的实例 C1</span><br><span class="line"></span><br><span class="line">      double dnum = 100.1;</span><br><span class="line">      int ifromd = (int)dnum; // double类型显式转换转为int类型</span><br><span class="line"></span><br><span class="line">      Class1 c11 = new Class1();</span><br><span class="line">      Class2 c22 = c11 as Class2; // 使用as进行显式转换</span><br><span class="line">      Console.WriteLine(c22 is Class1);</span><br><span class="line">      Console.WriteLine(c22 is Class2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的运行结果为：</p><blockquote><p>FALSE<br>FALSE</p></blockquote><p>显式转换可能会导致数据出错，或者转换失败，甚至无法编译成功。</p><h2 id="C-类型转换方法"><a href="#C-类型转换方法" class="headerlink" title="C# 类型转换方法"></a>C# 类型转换方法</h2><p>如<code>ToDouble()</code>，把其他类型转换成双精度浮点型:<code>string locstr = 123.ToString()</code><br>而将”locstr”转换成整型，则有以下几种方法：<br>1、Convert<br><code>int i = Convert.ToInt16(locstr)</code><br>2、Parse<br><code>int i = int.Parse(locstr)</code><br>3、<code>int.TryParse(String s,out int i)</code>，最后一个参数result是输出值，如果转换成功则输出相应的值，转换失败则输出0。<br><br><br><br><br><br></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序结构&quot;&gt;&lt;a href=&quot;#程序结构&quot; class=&quot;headerlink&quot; title=&quot;程序结构&quot;&gt;&lt;/a&gt;程序结构&lt;/h1&gt;&lt;h2 id=&quot;Hello-World实例&quot;&gt;&lt;a href=&quot;#Hello-World实例&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="高级程序语言" scheme="https://aoxiaodie.github.io/categories/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>HPL环境安装与错误集合</title>
    <link href="https://aoxiaodie.github.io/2018/02/01/HPL/"/>
    <id>https://aoxiaodie.github.io/2018/02/01/HPL/</id>
    <published>2018-02-01T05:18:11.000Z</published>
    <updated>2019-02-26T06:31:46.525Z</updated>
    
    <content type="html"><![CDATA[<p>LINPACK是线性系统软件包(Linear system package) 的缩写，其用于测试高性能计算机系统浮点性能的benchmark。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。<br>而HPL（High Performance Linpack）是Linpack测试三类之一。</p><p>搭建HPL测试环境主要有这些步骤：<br><b><a href="#bianyiqi">编译器的安装</a></b><br><b><a href="#GotoBLAS2">数学库GotoBLAS2</a></b><br><b><a href="#MPICH">并行环境MPICH</a></b><br><b><a href="#hpl">hpl</a></b></p><p>系统环境：ubuntu 16.04 LTS<br><br><br><br><br><br></p><hr><p><a id="bianyiqi"><b>编译器的安装</b></a><br>（1）gcc（一般系统自带）<br>可以用下面的指令查看<code>gcc --version</code>。<br><br><br>（2）gfortran（可选，我安装了gfortran 5.4.0）<br>主要是后面编译MPICH时需要用到，如果不安装，可以直接加<code>--disable-gfortran</code>。<br><br><br><br><br><br></p><hr><p><a id="GotoBLAS2"><b>数学库GotoBLAS2</b></a><br>（1）直接在官网上下载：GotoBLAS2-1.13.tar.gz<br>（2）解压：<code>tar -xzf GotoBLAS2-1.13.tar.gz</code><br>（3）在解压后的文件夹中运行：<code>make CC=gcc BINARY=64 TARGET=NEHALEM</code>，但是如果用这种方法编译，会遇到下面这个错误，直接影响最后hpl的编译。<br>错误信息：</p><blockquote><p>linux/bin/ld: cannot find -l-l<br>collect2: error: ld returned 1 exit status</p></blockquote><p>解决方法就是找到文件夹中的f_check，修改第298行：<code>print MAKEFILE &quot;FEXTRALIB=$linker_L   -lgfortran -lm -lquadmath -lm $linker_a\n&quot;;</code><br><img src="assets/image.data/HPL/GotoBLAS2_error.png" alt="GotoBLAS2"><br><br><br>当然，也可以用另一种方法，修改GotoBLAS2文件夹中的<code>Makefile.rule</code>，去掉注释</p><blockquote><p>VERSION = 1.13<br>TARGET = NEHALEM<br>BINARY=64        //64位操作系统<br>USE_OPENMP = 1<br>INTERFACE64 = 1</p></blockquote><p>然后运行GotoBLAS2中的建立文件，即: <code>./quickbuild.64bit</code>。<br>如果出现下面这些，则表示安装成功。<br><img src="assets/image.data/HPL/GotoBLAS2_success.png" alt="GotoBLAS2_SUCCESS"><br><br><br><br><br><br></p><hr><p><a id="MPICH"><b>并行环境MPICH</b></a><br>（1）在官网下载：<strong>不要下载mpich-3.2.1，这个版本的在编译后会缺少“libmpich.a”文件，导致最后make arch时候一直报错，为了这个error我纠结了好几天。</strong><br><br><br>当时用了3.2.1版本，前面都没有出错，到最后<code>make arch=Linux</code>时，会一直报错。<br>错误信息：</p><blockquote><p>gfortran:error:/home/mpich-3.2.1/lib/libmpich.a:没有那个文件或目录</p></blockquote><p>然后我打开lib文件夹发现真的没有这个文件，只有“libmpich.so”文件（.a是静态链接库，.so是动态链接库）<br><br><br>我把它改成“libmpich.so”或者“libmpi.a”，结果还是报错<br>错误信息：</p><blockquote><p>collect2: error: ld returned 1 exit status<br>Makefile:76: recipe for target ‘dexe.grd’ failed<br>make[2]: [dexe.grd] Error 1<br>make[2]: Leaving directory ‘/home/…’<br>Make.top:64: recipe for target ‘build_tst’ failed<br>make[1]: [build_tst] Error 2<br>make[1]: Leaving directory ‘/home/…’<br>Makefile:72: recipe for target ‘build’ failed<br>make: [build] Error 2</p></blockquote><p><br><br>最简单粗暴的解决方法就是换一个版本。<br><img src="assets/image.data/HPL/mpich.png" alt="mpich-3.0.4"></p><p><center><strong>下载3.0.4版本</strong></center><br><br><br>（2）解压<br>（3）建一个安装文件夹setmpich<br>（4）在解压文件夹中：<code>./configure --prefix=/home/username/setmpich</code>，路径写setmpich文件夹所在的路径，可以在该文件夹中运行<code>pwd</code>查看。<br>（5）make<br>（6）make install<br>（7）配置环境变量，如果没有安装Vim，直接<code>gedit ~/.bashrc</code><br>在最后添加：</p><blockquote><p>export PATH=/home/username/setmpich/bin:$PATH<br>export LD_LIBRARY_PATH=/home/username/setmpich/lib:$LD_LIBRARY_PATH</p></blockquote><p>保存并退出。<br>（8）更新配置：<code>source ~/.bashrc</code><br>（9）检测是否将命令导出成功：<code>which mpirun</code><br>如果成功就为会显示你的安装路径，如<code>/home/username/setmpich/bin</code><br>（10）测试<br>打开mpich解压文件夹中的examples，运行cpi：<code>mpiexec -np 4 ./cpi</code>，出现下列结果，则安装成功。<br><img src="..." alt="MPICH_SUCCESS"><br>（我忘记截图了…）<br><br><br><br><br><br></p><hr><p><a id="hpl"><b>hpl</b></a><br>（1）下载hpl-2.2<br>（2）解压<br>（3）在解压文件夹中的setup文件夹中找到文件Make.Linux_PII_FBLAS，并把它移到上层目录，然后重命名，我把它命名成Make.Linux<br>（4）修改Make.Linux文件：</p><blockquote><p>ARCH         = Linux<br>TOPdir       = $(HOME)/hpl-2.2   //  改为hpl解压后产生的文件夹<br>MPdir        = /home/username/setmpich   //  改为mpich安装文件夹<br>LAdir        = $(HOME)/GotoBLAS2 //  GotoBLAS2解压文件夹<br>LAlib        = $(LAdir)/libgoto2.a $(LAdir)/libgoto2.so<br>HPL_OPTS     = -DHPL_CALL_CBLAS<br>CC           = /home/username/setmpich/bin/mpicc<br>LINKER       = /home/username/setmpich/bin/mpif77</p></blockquote><p>（5）在解压文件夹下<code>make arch=Linux</code><br>此时安装文件夹下bin中会有Linux文件夹，打开，如果看到HPL.dat  xhpl这两个文件，则安装成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LINPACK是线性系统软件包(Linear system package) 的缩写，其用于测试高性能计算机系统浮点性能的benchmark。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。&lt;br&gt;而HPL（High Pe
      
    
    </summary>
    
      <category term="Linpack测试环境搭建问题集合" scheme="https://aoxiaodie.github.io/categories/Linpack%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>learnOpenGL</title>
    <link href="https://aoxiaodie.github.io/2017/12/20/games-development/learnopengl/"/>
    <id>https://aoxiaodie.github.io/2017/12/20/games-development/learnopengl/</id>
    <published>2017-12-20T15:25:41.000Z</published>
    <updated>2018-08-19T09:14:33.822Z</updated>
    
    <content type="html"><![CDATA[<p>随便写一写</p><h1 id="几个库"><a href="#几个库" class="headerlink" title="几个库"></a>几个库</h1><h2 id="GLFW库"><a href="#GLFW库" class="headerlink" title="GLFW库"></a>GLFW库</h2><p>简单来说就是，显示图形窗口必须的库。<br>下面是一个简单的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化glfw库</span></span><br><span class="line">    <span class="keyword">if</span> (!glfwInit())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个窗口和它的OpenGL上下文</span></span><br><span class="line">    window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有创建会返回NULL</span></span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前的窗口上下文</span></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环，直到用户关闭窗口</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在这里做渲染</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换缓冲区，即在window上更新内容</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮询事件</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://www.jianshu.com/p/0ebe2b38d81c" target="_blank" rel="noopener">GLFW入门学习</a><br><br><br><br></p><h2 id="GLAD库"><a href="#GLAD库" class="headerlink" title="GLAD库"></a>GLAD库</h2><p>有点难以理解和解释，反正一定需要就对了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><hr><h1 id="最基本的窗口实现"><a href="#最基本的窗口实现" class="headerlink" title="最基本的窗口实现"></a>最基本的窗口实现</h1><p>直接上代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;<span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;<span class="comment">// 键盘输入控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义窗口小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化glfw</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">// 版本信息</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">// 版本信息</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// 如果使用的是Mac OS X系统，需要添加这行代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个窗口对象</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// 第三个参数是窗口标题</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);<span class="comment">// 窗口回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空颜色缓冲，并设置背景颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span><span class="comment">// 键盘输入控制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">// esc键退出</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用户改变窗口的大小的时候，视口也被调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);<span class="comment">// 视口，渲染窗口的尺寸大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><hr><h1 id="非常重要的着色器部分"><a href="#非常重要的着色器部分" class="headerlink" title="非常重要的着色器部分"></a>非常重要的着色器部分</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>顶点数组对象：Vertex Array Object，VAO<br>顶点缓冲对象：Vertex Buffer Object，VBO<br>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO<br><br><br><br><br>那一堆概念看得我脑袋疼，然后在知乎上找到了通俗版的解释。<br><a href="https://www.zhihu.com/question/29163054" target="_blank" rel="noopener">如何理解OpenGL中着色器，渲染管线，光栅化等概念？</a><br><br><br>1.渲染管线（Pipeline）:</p><blockquote><p>其实是指三维渲染的过程中显卡执行的、从几何体到最终渲染图像的、数据传输处理计算的过程</p></blockquote><p>2.着色器（类比画画）</p><blockquote><p>顶点着色器（vertex shader）这个是告诉电脑如何打线稿的——如何处理顶点、法线等的数据的小程序。<br>片面着色器（fragment shader）这个是告诉电脑如何上色的——如何处理光、阴影、遮挡、环境等等对物体表面的影响，最终生成一副图像的小程序。</p></blockquote><p>采用了这两种着色器小程序的数据传输处理计算的渲染过程，称之为可编程管线。<br><br><br><br></p><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>着色器是使用一种叫 <strong>GLSL</strong> (OpenGL Shading Language)的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。<br><br></p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>1、数据类型<br>包含C等其它语言大部分的默认基础数据类型。<br>两种容器类型：向量(Vector)和矩阵(Matrix)。</p><p>在GLSL中一个向量有最多4个分量，分量可以用vecn类型来定义。<br>每个分量值都代表空间中的一个坐标，它们可以通过 <strong>vec.x、vec.y、vec.z和vec.w</strong> 来获取。<br><br><br><br></p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core<span class="comment">// 版本声明</span></span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;<span class="comment">// 因为顶点着色器的输入比较特殊，直接接收顶点数据的输入，所以设置layout (location = 0)</span></span><br><span class="line">                                  <span class="comment">// 使用in关键字，在顶点着色器中声明所有的输入顶点属性</span></span><br><span class="line">                                  <span class="comment">// 如果每个顶点都有一个3D坐标，我们就创建一个vec3输入变量aPos</span></span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);<span class="comment">// 把位置数据（即我们的顶点输入）赋值给预定义的gl_Position变量</span></span><br><span class="line">                                                    <span class="comment">// 再把它传到着色器的输出</span></span><br><span class="line">    vertexColor = vec4(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>简单来说，就是负责颜色输出。<br>在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA，并把颜色每个分量的强度设置在0.0到1.0之间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core<span class="comment">// 版本声明</span></span></span><br><span class="line">out vec4 FragColor;<span class="comment">// 用out关键字声明输出变量</span></span><br><span class="line">                   <span class="comment">// 片段着色器只需要一个输出变量，即输出颜色的4分量向量</span></span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="uniform变量"><a href="#uniform变量" class="headerlink" title="uniform变量"></a>uniform变量</h2><p>uniform变量就像是C语言里面的常量（const ），它不能被shader程序修改。（shader只能用，不能改）。<br>如果uniform变量在vertex和fragment两者之间声明方式完全一样，则它可以在vertex和fragment共享使用。（相当于一个被vertex和fragment shader共享的全局变量）。<br>无论uniform值被设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。<br><br></p><h2 id="关于数据的输入"><a href="#关于数据的输入" class="headerlink" title="关于数据的输入"></a>关于数据的输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">  <span class="comment">// 索引缓冲对象，绘制两个三角形来组成一个矩形</span></span><br><span class="line">  <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">  <span class="comment">// 第二个三角形</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">  <span class="comment">// 顶点缓冲对象</span></span><br><span class="line">  <span class="comment">//0.5f, 0.5f, 0.0f,  // 右上</span></span><br><span class="line">  <span class="comment">//0.5f, -0.5f, 0.0f,  // 右下</span></span><br><span class="line">  <span class="comment">//-0.5f, -0.5f, 0.0f,  // 左下</span></span><br><span class="line">  <span class="comment">//-0.5f, 0.5f, 0.0f   // 左上</span></span><br><span class="line">  <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,  <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>   <span class="comment">// 第二个三角形</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;<span class="comment">//定义顶点缓冲对象</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;<span class="comment">//定义索引缓冲对象</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO; <span class="comment">//定义顶点缓冲数组</span></span><br><span class="line">  glGenVertexArrays(<span class="number">1</span>, &amp;VAO);<span class="comment">//创建顶点缓冲数组</span></span><br><span class="line">  glGenBuffers(<span class="number">1</span>, &amp;VBO);<span class="comment">//创建顶点缓冲对象</span></span><br><span class="line">  glGenBuffers(<span class="number">1</span>, &amp;EBO);<span class="comment">//创建索引缓冲对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定顶点数组对象</span></span><br><span class="line">  glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">  glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">  glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把索引数组复制到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">  glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置顶点属性指针</span></span><br><span class="line">  glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">  glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">  glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">  &#123;</span><br><span class="line">    ...;</span><br><span class="line">    ourShader.use();</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);<span class="comment">// 绑定VAO</span></span><br><span class="line">    glPolygonMode(GL_FRONT_AND_BACK, <span class="comment">/*GL_LINE*/</span>GL_FILL);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">// glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元</span></span><br><span class="line">                                     <span class="comment">// 第二个参数指定了顶点数组的起始索引</span></span><br><span class="line">                                     <span class="comment">// 最后一个参数指定绘制顶点的个数</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><hr><h1 id="纹理贴图"><a href="#纹理贴图" class="headerlink" title="纹理贴图"></a>纹理贴图</h1><h2 id="生成一个纹理"><a href="#生成一个纹理" class="headerlink" title="生成一个纹理"></a>生成一个纹理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片纹理</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ourTexture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;ourTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定纹理</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, ourTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理环绕</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<span class="comment">//第一个参数指定了纹理目标。</span></span><br><span class="line"> <span class="comment">//第二个参数需要指定设置的选项与应用的纹理轴。</span></span><br><span class="line"> <span class="comment">//最后一个参数需要我们传递一个环绕方式。</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*如果选择GL_CLAMP_TO_BORDER选项，则需指定一个边缘的颜色。*/</span></span><br><span class="line"> <span class="comment">//float borderColor[] = &#123; 1.0f,1.0f,0.0f,1.0f &#125;;</span></span><br><span class="line"> <span class="comment">//glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理过滤</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载纹理图片</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;<span class="comment">//用图像的宽度、高度和颜色通道的个数填充这三个变量。</span></span><br><span class="line">stbi_set_flip_vertically_on_load(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">"container.jpg"</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">  glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">  glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to load texture"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><p><br></p><h2 id="添加一个纹理属性"><a href="#添加一个纹理属性" class="headerlink" title="添加一个纹理属性"></a>添加一个纹理属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 纹理属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><br></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">processInput(window);</span><br><span class="line"></span><br><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line">ourShader.use();</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line">glfwPollEvents();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p><br></p><h2 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="片段着色器-1"><a href="#片段着色器-1" class="headerlink" title="片段着色器"></a>片段着色器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = texture(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两张图片的情况"><a href="#两张图片的情况" class="headerlink" title="两张图片的情况"></a>两张图片的情况</h2><p>顶点着色器中：<code>TexCoord = vec2(aTexCoord.x, aTexCoord.y);</code><br>片段着色器中：<code>FragColor = mix(texture(ourTexture, TexCoord), texture(faceTexture, TexCoord), 0.5);</code><br><br><br><br><br><br></p><hr><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><h2 id="GLM库"><a href="#GLM库" class="headerlink" title="GLM库"></a>GLM库</h2><p>变换中需要用到矩阵和向量等数学知识，所以用到GLM数学库。<br><br></p><h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;<span class="comment">//创建一个4×4的变换矩阵</span></span><br><span class="line">trans = glm::translate(trans,glm::vec3(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>));<span class="comment">//平移变换</span></span><br><span class="line">trans = glm::rotate(trans,glm::radians(<span class="number">90.0f</span>),glm::vec3(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>));<span class="comment">//旋转</span></span><br><span class="line">trans = glm::scale(trans,glm::vec(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>));<span class="comment">//缩放0.5倍</span></span><br></pre></td></tr></table></figure><p>顶点着色器中的位置向量修改为：<code>gl_Position = trans * vec4(aPos,1.0f)</code><br><br></p><h2 id="不知道什么的东西"><a href="#不知道什么的东西" class="headerlink" title="不知道什么的东西"></a>不知道什么的东西</h2><p><strong>视觉坐标</strong><br>视觉坐标是相对于观察者而言的，可以说是“绝对的”屏幕坐标，它表示一个虚拟的固定坐标系，通常作为参考坐标系使用。</p><p><strong>视图变换</strong><br>确定视图变换就像在场景中放置照相机并让它指向某个方向。</p><p><strong>模型变换</strong><br>用于操控模型，将对象移动到需要的位置，再对它们进行位移、缩放和旋转操作。</p><p><strong>投影变换</strong><br>透视投影。</p><p><strong>视口变换</strong><br>对窗口上的最终输出进行缩放。<br><br></p><h2 id="为3D做准备"><a href="#为3D做准备" class="headerlink" title="为3D做准备"></a>为3D做准备</h2><p>打开深度测试：<code>glEnable(GL_DEPTH_TEST);</code><br>清除深度缓存：<code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</code></p><p><strong>模型矩阵</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::rotate(model, glm::radians(<span class="number">-55.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure></p><p>通过将顶点坐标乘以模型矩阵，将其变换到世界坐标。<br><br><br><strong>观察矩阵</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure></p><p>主要是控制物体在场景中移动。<br><br><br><strong>投影矩阵</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></p><p><br><br>将矩阵传入着色器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> modelLoc = glGetUniformLocation(ourShader.ID, <span class="string">"model"</span>));</span><br><span class="line">glUniformMatrix4fv(modelLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(model));</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> viewLoc  = glGetUniformLocation(ourShader.ID, <span class="string">"view"</span>);</span><br><span class="line">glUniformMatrix4fv(viewLoc, <span class="number">1</span>, GL_FALSE, &amp;view[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">ourShader.setMat4(<span class="string">"projection"</span>, projection);</span><br></pre></td></tr></table></figure></p><p><br><br>在顶点着色器中修改位置向量：<code>gl_Position = projection * view * model * vec4(aPos, 1.0)</code></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随便写一写&lt;/p&gt;
&lt;h1 id=&quot;几个库&quot;&gt;&lt;a href=&quot;#几个库&quot; class=&quot;headerlink&quot; title=&quot;几个库&quot;&gt;&lt;/a&gt;几个库&lt;/h1&gt;&lt;h2 id=&quot;GLFW库&quot;&gt;&lt;a href=&quot;#GLFW库&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="游戏开发" scheme="https://aoxiaodie.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
